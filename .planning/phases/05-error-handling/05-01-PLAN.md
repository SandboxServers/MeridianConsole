---
phase: 05-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Shared/Dhadgar.ServiceDefaults/Errors/DomainExceptions.cs
  - src/Shared/Dhadgar.ServiceDefaults/Errors/GlobalExceptionHandler.cs
  - src/Shared/Dhadgar.ServiceDefaults/Errors/ErrorHandlingExtensions.cs
  - src/Shared/Dhadgar.ServiceDefaults/Middleware/ProblemDetailsMiddleware.cs
  - tests/Dhadgar.ServiceDefaults.Tests/Errors/GlobalExceptionHandlerTests.cs
  - tests/Dhadgar.ServiceDefaults.Tests/Errors/DomainExceptionTests.cs
autonomous: true

must_haves:
  truths:
    - "Exceptions thrown in services map to appropriate HTTP status codes"
    - "All error responses include traceId and correlationId fields"
    - "5xx error responses in production do not contain stack traces or internal details"
    - "4xx error responses include descriptive detail messages"
  artifacts:
    - path: "src/Shared/Dhadgar.ServiceDefaults/Errors/DomainExceptions.cs"
      provides: "Exception taxonomy (ValidationException, NotFoundException, etc.)"
      exports: ["DomainException", "ValidationException", "NotFoundException", "ConflictException", "UnauthorizedException", "ForbiddenException"]
    - path: "src/Shared/Dhadgar.ServiceDefaults/Errors/GlobalExceptionHandler.cs"
      provides: "IExceptionHandler implementation for exception classification"
      exports: ["GlobalExceptionHandler"]
    - path: "src/Shared/Dhadgar.ServiceDefaults/Errors/ErrorHandlingExtensions.cs"
      provides: "DI registration for error handling"
      exports: ["AddDhadgarErrorHandling", "UseDhadgarErrorHandling"]
  key_links:
    - from: "GlobalExceptionHandler"
      to: "DomainExceptions"
      via: "pattern matching on exception type"
      pattern: "exception switch.*DomainException"
    - from: "ErrorHandlingExtensions"
      to: "GlobalExceptionHandler"
      via: "services.AddExceptionHandler<GlobalExceptionHandler>()"
      pattern: "AddExceptionHandler<GlobalExceptionHandler>"
---

<objective>
Create RFC 9457 Problem Details infrastructure with exception classification, trace context enrichment, and production-safe error handling.

Purpose: Establish centralized error handling that all services inherit, ensuring consistent error responses with debugging context (ERR-01, ERR-02, ERR-03, ERR-04).

Output: Exception taxonomy, GlobalExceptionHandler, registration extensions, and unit tests in ServiceDefaults.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-error-handling/05-RESEARCH.md

# Existing middleware to enhance
@src/Shared/Dhadgar.ServiceDefaults/Middleware/ProblemDetailsMiddleware.cs
@src/Shared/Dhadgar.ServiceDefaults/ServiceDefaultsExtensions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exception taxonomy and GlobalExceptionHandler</name>
  <files>
    src/Shared/Dhadgar.ServiceDefaults/Errors/DomainExceptions.cs
    src/Shared/Dhadgar.ServiceDefaults/Errors/GlobalExceptionHandler.cs
  </files>
  <action>
Create the Errors directory in ServiceDefaults and implement:

**DomainExceptions.cs:**
- `DomainException` abstract base class with `StatusCode` (int) and `ErrorType` (string) abstract properties
- `ValidationException` (400) with optional `IDictionary<string, string[]>? Errors` for field-level validation errors
- `NotFoundException` (404) with optional `ResourceType` and `ResourceId` properties
- `ConflictException` (409) for duplicate/conflict scenarios
- `UnauthorizedException` (401) for authentication failures
- `ForbiddenException` (403) for authorization failures
- Use `https://meridian.console/errors/{type}` as error type URIs (e.g., `https://meridian.console/errors/validation`)

**GlobalExceptionHandler.cs:**
- Implement `IExceptionHandler` interface from `Microsoft.AspNetCore.Diagnostics`
- Inject `ILogger<GlobalExceptionHandler>`, `IHostEnvironment`, `TimeProvider`
- In `TryHandleAsync`:
  1. Get traceId using existing fallback chain: `Activity.Current?.TraceId.ToString() ?? httpContext.Items["CorrelationId"]?.ToString() ?? httpContext.TraceIdentifier ?? "unknown"`
  2. Get correlationId from `httpContext.Items["CorrelationId"]?.ToString() ?? httpContext.TraceIdentifier ?? "unknown"`
  3. Log exception with TraceId, CorrelationId, and Path at Error level
  4. Classify exception using pattern matching (see research for full mapping)
  5. Create `ProblemDetails` with type, title, status, instance, detail
  6. Add `traceId`, `correlationId`, `timestamp` to Extensions dictionary
  7. For `ValidationException`, add `errors` field to Extensions
  8. Use `GetSafeDetail()` helper: Include exception.Message only if IsDevelopment/Testing OR statusCode < 500
  9. Set ContentType to `application/problem+json`
  10. Return true (exception handled)

Exception classification mapping:
- DomainException -> use its StatusCode and ErrorType
- ArgumentNullException, ArgumentException, InvalidOperationException -> 400
- UnauthorizedAccessException -> 401
- KeyNotFoundException -> 404
- NotImplementedException -> 501
- TimeoutException -> 504
- OperationCanceledException -> 499 (client closed)
- Default -> 500

Use EventId 9300 for exception logging to avoid conflict with audit (9200-9229).
  </action>
  <verify>
    dotnet build src/Shared/Dhadgar.ServiceDefaults
  </verify>
  <done>
    DomainException hierarchy exists with 5 concrete exception types.
    GlobalExceptionHandler implements IExceptionHandler and classifies exceptions to appropriate status codes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create registration extensions and update middleware</name>
  <files>
    src/Shared/Dhadgar.ServiceDefaults/Errors/ErrorHandlingExtensions.cs
    src/Shared/Dhadgar.ServiceDefaults/Middleware/ProblemDetailsMiddleware.cs
  </files>
  <action>
**ErrorHandlingExtensions.cs:**
Create extension methods for clean registration:

```csharp
public static class ErrorHandlingExtensions
{
    public static IServiceCollection AddDhadgarErrorHandling(this IServiceCollection services)
    {
        services.AddProblemDetails(options =>
        {
            options.CustomizeProblemDetails = context =>
            {
                // Ensure trace IDs are always present (for Results.Problem() calls)
                var traceId = Activity.Current?.TraceId.ToString()
                    ?? context.HttpContext.Items["CorrelationId"]?.ToString()
                    ?? context.HttpContext.TraceIdentifier
                    ?? "unknown";

                var correlationId = context.HttpContext.Items["CorrelationId"]?.ToString()
                    ?? context.HttpContext.TraceIdentifier
                    ?? "unknown";

                context.ProblemDetails.Extensions.TryAdd("traceId", traceId);
                context.ProblemDetails.Extensions.TryAdd("correlationId", correlationId);
                context.ProblemDetails.Extensions.TryAdd("timestamp", TimeProvider.System.GetUtcNow());
            };
        });

        services.AddExceptionHandler<GlobalExceptionHandler>();

        return services;
    }

    public static IApplicationBuilder UseDhadgarErrorHandling(this IApplicationBuilder app)
    {
        // UseExceptionHandler activates IExceptionHandler implementations
        app.UseExceptionHandler();

        // StatusCodePages handles non-exception errors (404 from routing, etc.)
        app.UseStatusCodePages(async context =>
        {
            // Only handle if response body hasn't been written
            if (!context.HttpContext.Response.HasStarted)
            {
                var traceId = Activity.Current?.TraceId.ToString()
                    ?? context.HttpContext.Items["CorrelationId"]?.ToString()
                    ?? context.HttpContext.TraceIdentifier
                    ?? "unknown";

                var correlationId = context.HttpContext.Items["CorrelationId"]?.ToString()
                    ?? context.HttpContext.TraceIdentifier
                    ?? "unknown";

                var statusCode = context.HttpContext.Response.StatusCode;
                var problemDetails = new ProblemDetails
                {
                    Type = $"https://httpstatuses.com/{statusCode}",
                    Title = GetTitle(statusCode),
                    Status = statusCode,
                    Instance = context.HttpContext.Request.Path
                };
                problemDetails.Extensions["traceId"] = traceId;
                problemDetails.Extensions["correlationId"] = correlationId;
                problemDetails.Extensions["timestamp"] = TimeProvider.System.GetUtcNow();

                context.HttpContext.Response.ContentType = "application/problem+json";
                await context.HttpContext.Response.WriteAsJsonAsync(problemDetails);
            }
        });

        return app;
    }

    private static string GetTitle(int statusCode) => statusCode switch
    {
        400 => "Bad Request",
        401 => "Unauthorized",
        403 => "Forbidden",
        404 => "Not Found",
        405 => "Method Not Allowed",
        409 => "Conflict",
        429 => "Too Many Requests",
        500 => "Internal Server Error",
        502 => "Bad Gateway",
        503 => "Service Unavailable",
        504 => "Gateway Timeout",
        _ => "Error"
    };
}
```

**ProblemDetailsMiddleware.cs:**
Update the existing middleware to:
1. Add `correlationId` as a separate field alongside `traceId`
2. Use the standard `ProblemDetails` class instead of anonymous type
3. Add `timestamp` extension field
4. Keep as fallback for any exceptions not caught by IExceptionHandler

The middleware continues to exist as a safety net - GlobalExceptionHandler is the primary handler.
  </action>
  <verify>
    dotnet build src/Shared/Dhadgar.ServiceDefaults
  </verify>
  <done>
    AddDhadgarErrorHandling() and UseDhadgarErrorHandling() extension methods exist.
    ProblemDetailsMiddleware includes correlationId and timestamp fields.
    All error responses now include both traceId and correlationId.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for error handling infrastructure</name>
  <files>
    tests/Dhadgar.ServiceDefaults.Tests/Errors/GlobalExceptionHandlerTests.cs
    tests/Dhadgar.ServiceDefaults.Tests/Errors/DomainExceptionTests.cs
  </files>
  <action>
Create comprehensive tests for the error handling infrastructure:

**DomainExceptionTests.cs:**
- Test each exception type returns correct StatusCode
- Test each exception type returns correct ErrorType URI
- Test ValidationException.Errors property stores field errors
- Test NotFoundException with ResourceType/ResourceId constructor

**GlobalExceptionHandlerTests.cs:**
- Use TestServer or mock HttpContext to test exception handling
- Test: DomainException -> returns its StatusCode
- Test: ArgumentException -> returns 400
- Test: KeyNotFoundException -> returns 404
- Test: OperationCanceledException -> returns 499
- Test: Generic Exception -> returns 500
- Test: Response includes traceId field
- Test: Response includes correlationId field
- Test: Response includes timestamp field
- Test: Production mode (non-Development) hides exception.Message for 5xx
- Test: Development mode includes exception.Message for 5xx
- Test: 4xx always includes exception.Message
- Test: ValidationException response includes errors dictionary
- Test: Response ContentType is application/problem+json

Mock IHostEnvironment to test Development vs Production behavior.
Use TimeProvider.System or a fake TimeProvider for timestamp testing.
  </action>
  <verify>
    dotnet test tests/Dhadgar.ServiceDefaults.Tests --filter "FullyQualifiedName~Errors"
  </verify>
  <done>
    All unit tests pass.
    Tests cover exception classification, trace context inclusion, and production safety.
  </done>
</task>

</tasks>

<verification>
```bash
# Build ServiceDefaults
dotnet build src/Shared/Dhadgar.ServiceDefaults

# Run error handling tests
dotnet test tests/Dhadgar.ServiceDefaults.Tests --filter "FullyQualifiedName~Errors"

# Verify new files exist
ls -la src/Shared/Dhadgar.ServiceDefaults/Errors/

# Verify exports compile
grep -r "AddDhadgarErrorHandling\|GlobalExceptionHandler\|DomainException" src/Shared/Dhadgar.ServiceDefaults/
```
</verification>

<success_criteria>
- [ ] DomainException hierarchy with 5 concrete exception types (Validation, NotFound, Conflict, Unauthorized, Forbidden)
- [ ] GlobalExceptionHandler classifies exceptions to correct HTTP status codes
- [ ] All error responses include traceId and correlationId fields
- [ ] Production errors (5xx) do not expose exception.Message or stack traces
- [ ] Development errors include exception.Message for debugging
- [ ] AddDhadgarErrorHandling() and UseDhadgarErrorHandling() extension methods available
- [ ] Unit tests pass for all exception types and trace context inclusion
</success_criteria>

<output>
After completion, create `.planning/phases/05-error-handling/05-01-SUMMARY.md`
</output>
