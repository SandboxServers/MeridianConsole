---
phase: 03-audit-system
plan: 03-01
title: Core Audit Infrastructure
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Shared/Dhadgar.ServiceDefaults/Audit/ApiAuditRecord.cs
  - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditQueue.cs
  - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditMiddleware.cs
  - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditWriterService.cs
  - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditCleanupService.cs
  - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditExtensions.cs
  - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditMessages.cs
  - src/Shared/Dhadgar.ServiceDefaults/Dhadgar.ServiceDefaults.csproj
autonomous: true

must_haves:
  truths:
    - "AuditMiddleware captures HTTP method, path, status code, user ID, tenant ID for authenticated requests"
    - "Audit events are queued without blocking the request thread"
    - "Background service batch-writes queued events to database"
    - "Cleanup service deletes records older than 90 days"
  artifacts:
    - path: "src/Shared/Dhadgar.ServiceDefaults/Audit/ApiAuditRecord.cs"
      provides: "Audit entity with all required fields"
      contains: "public sealed class ApiAuditRecord"
    - path: "src/Shared/Dhadgar.ServiceDefaults/Audit/AuditQueue.cs"
      provides: "Channel-based non-blocking queue"
      contains: "Channel<ApiAuditRecord>"
    - path: "src/Shared/Dhadgar.ServiceDefaults/Audit/AuditMiddleware.cs"
      provides: "HTTP request capture middleware"
      contains: "public sealed class AuditMiddleware"
    - path: "src/Shared/Dhadgar.ServiceDefaults/Audit/AuditWriterService.cs"
      provides: "Background batch writer"
      contains: "BackgroundService"
    - path: "src/Shared/Dhadgar.ServiceDefaults/Audit/AuditCleanupService.cs"
      provides: "90-day retention cleanup"
      contains: "RetentionPeriod"
    - path: "src/Shared/Dhadgar.ServiceDefaults/Audit/AuditExtensions.cs"
      provides: "DI registration extension"
      contains: "AddAuditInfrastructure"
  key_links:
    - from: "AuditMiddleware"
      to: "IAuditQueue"
      via: "QueueAsync call"
      pattern: "_auditQueue\\.QueueAsync"
    - from: "AuditWriterService"
      to: "IAuditQueue"
      via: "ReadAllAsync drain"
      pattern: "_queue\\.ReadAllAsync"
---

# Core Audit Infrastructure

## Objective

Create the shared audit infrastructure in ServiceDefaults that all services can use. This includes the audit entity, non-blocking channel queue, capture middleware, batch writer service, and cleanup service for 90-day retention.

Purpose: Provides reusable audit components following the Channel + BackgroundService pattern from research.
Output: Audit infrastructure ready to be wired into individual services.

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-audit-system/03-RESEARCH.md
@src/Shared/Dhadgar.ServiceDefaults/ServiceDefaultsExtensions.cs
@src/Dhadgar.Identity/Services/TokenCleanupService.cs
@src/Dhadgar.Identity/Data/Entities/AuditEvent.cs
@src/Shared/Dhadgar.ServiceDefaults/Middleware/RequestLoggingMiddleware.cs

## Tasks

<task id="1" type="auto">
  <name>Create audit entity and queue</name>
  <files>
    - src/Shared/Dhadgar.ServiceDefaults/Audit/ApiAuditRecord.cs
    - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditQueue.cs
  </files>
  <action>
Create the Audit folder in ServiceDefaults.

**ApiAuditRecord.cs** - Entity for audit records (NOT added to any DbContext in ServiceDefaults - services add to their own):
- `Id` (Guid, default NewGuid)
- `TimestampUtc` (DateTime)
- `UserId` (Guid?, from JWT sub claim)
- `TenantId` (Guid?, from JWT org_id claim)
- `HttpMethod` (string, required, max 10)
- `Path` (string, required, max 500)
- `ResourceId` (Guid?, extracted from path)
- `ResourceType` (string?, max 50, e.g., "server", "node")
- `StatusCode` (int)
- `DurationMs` (long)
- `ClientIp` (string?, max 45)
- `UserAgent` (string?, max 256)
- `CorrelationId` (string?, max 64)
- `TraceId` (string?, max 32)
- `ServiceName` (string?, max 50)

Add XML documentation explaining this is for HTTP request auditing, not Identity's domain events.

**AuditQueue.cs** - Channel-based queue:
- `IAuditQueue` interface with `QueueAsync` and `ReadAllAsync` methods
- `AuditQueue` implementation using `Channel.CreateBounded<ApiAuditRecord>`
- `AuditQueueOptions` class with `Capacity` property (default 10,000)
- Use `BoundedChannelOptions` with `FullMode = Wait`, `SingleReader = true`, `SingleWriter = false`

Follow pattern from research section "Complete Audit Queue Implementation".
  </action>
  <verify>
Files compile: `dotnet build src/Shared/Dhadgar.ServiceDefaults`
  </verify>
  <done>
ApiAuditRecord entity exists with all required fields. IAuditQueue interface and AuditQueue implementation exist with Channel-based queueing.
  </done>
</task>

<task id="2" type="auto">
  <name>Create audit middleware</name>
  <files>
    - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditMiddleware.cs
  </files>
  <action>
Create `AuditMiddleware` that captures HTTP requests for authenticated users only.

Key behavior:
1. Skip if `context.User.Identity?.IsAuthenticated != true` (per AUDIT-01: "authenticated API calls")
2. Skip health endpoints: paths starting with `/healthz`, `/livez`, `/readyz`
3. Use Stopwatch for timing (like RequestLoggingMiddleware)
4. Build ApiAuditRecord in finally block after response

Extract user/tenant from claims:
- `UserId`: Parse from `context.User.FindFirst("sub")?.Value` or `ClaimTypes.NameIdentifier`
- `TenantId`: Parse from `context.User.FindFirst("org_id")?.Value` or `context.User.FindFirst("tenant_id")?.Value`

Extract resource ID/type from path using regex:
```csharp
private static readonly Regex ResourceIdPattern = new(
    @"/(?:api/)?v?\d*/?(servers|nodes|users|organizations|tasks|files|mods)/([0-9a-fA-F-]{36})",
    RegexOptions.Compiled | RegexOptions.IgnoreCase);
```

Get TraceId from `Activity.Current?.TraceId.ToString()`.
Get CorrelationId from `context.Items["CorrelationId"]?.ToString()`.
Get ServiceName from cached assembly name (like TenantEnrichmentMiddleware pattern).

Queue the record using fire-and-forget: `_ = _auditQueue.QueueAsync(record)` (non-blocking).

Add helper extension method `Truncate(this string?, int maxLength)` for UserAgent truncation.
  </action>
  <verify>
Files compile: `dotnet build src/Shared/Dhadgar.ServiceDefaults`
  </verify>
  <done>
AuditMiddleware exists, skips unauthenticated requests and health endpoints, extracts all required fields, queues records without blocking.
  </done>
</task>

<task id="3" type="auto">
  <name>Create background services and DI extension</name>
  <files>
    - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditWriterService.cs
    - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditCleanupService.cs
    - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditExtensions.cs
    - src/Shared/Dhadgar.ServiceDefaults/Audit/AuditMessages.cs
  </files>
  <action>
**AuditWriterService.cs** - Background service that drains queue and batch-writes to database:
- `AuditWriterOptions` class with `BatchSize` (default 100), `FlushInterval` (default 5 seconds, for future timeout-based flush)
- Extend `BackgroundService`, inject `IAuditQueue`, `IServiceScopeFactory`, `ILogger<AuditWriterService>`, `IOptions<AuditWriterOptions>`
- In `ExecuteAsync`: `await foreach (var record in _queue.ReadAllAsync(stoppingToken))`, collect in batch list
- When batch.Count >= BatchSize, call FlushBatchAsync
- In shutdown, drain remaining records with `CancellationToken.None`
- `FlushBatchAsync`: Create scope, get DbContext via `IDbContextFactory<TContext>` pattern (services provide their own factory), call `AddRange` + `SaveChangesAsync`
- **Important**: The writer needs to work generically. Add `IAuditDbContext` interface with `DbSet<ApiAuditRecord> ApiAuditRecords { get; }` and `Task<int> SaveChangesAsync(CancellationToken ct)`. Services implement this on their DbContext.
- Log errors but don't throw (records lost is acceptable tradeoff per research)

**AuditCleanupService.cs** - Background service for 90-day retention:
- `AuditCleanupOptions` class with `Interval` (default 24 hours), `RetentionPeriod` (default 90 days), `BatchSize` (default 10,000), `Enabled` (default true)
- Follow TokenCleanupService pattern exactly:
  - Initial delay of 5 minutes
  - Loop with try/catch around cleanup
  - Batch delete using `ExecuteDeleteAsync` to avoid loading entities
  - Log count deleted
- Use `TimeProvider` for testability

**AuditMessages.cs** - Source-generated logging:
- Create `AuditMessages` class with `[LoggerMessage]` attributes for:
  - `LogAuditBatchWritten(int count)` - Debug level, EventId 9200
  - `LogAuditBatchFailed(int count, Exception ex)` - Error level, EventId 9201
  - `LogAuditCleanupCompleted(int count, DateTime cutoff)` - Information level, EventId 9210
  - `LogAuditCleanupFailed(Exception ex)` - Error level, EventId 9211
  - `LogAuditQueueFull()` - Warning level, EventId 9220

**AuditExtensions.cs** - DI registration:
- `AddAuditInfrastructure<TContext>(this IServiceCollection services, Action<AuditOptions>? configure = null)` where TContext : DbContext, IAuditDbContext
- Register: `AuditQueueOptions`, `AuditWriterOptions`, `AuditCleanupOptions` via Configure
- Register: `IAuditQueue` as Singleton (AuditQueue)
- Register: `AuditWriterService<TContext>` and `AuditCleanupService<TContext>` as HostedService
- Register: `AuditMessages` as Singleton
- `UseAuditMiddleware(this IApplicationBuilder app)` extension
  </action>
  <verify>
Files compile: `dotnet build src/Shared/Dhadgar.ServiceDefaults`
  </verify>
  <done>
AuditWriterService batch-writes to database. AuditCleanupService deletes records older than 90 days. AuditExtensions provides AddAuditInfrastructure and UseAuditMiddleware.
  </done>
</task>

## Verification

```bash
# Build ServiceDefaults
dotnet build src/Shared/Dhadgar.ServiceDefaults

# Verify new files exist
ls src/Shared/Dhadgar.ServiceDefaults/Audit/
# Expected: ApiAuditRecord.cs, AuditQueue.cs, AuditMiddleware.cs,
#           AuditWriterService.cs, AuditCleanupService.cs, AuditExtensions.cs, AuditMessages.cs

# Verify IAuditDbContext interface exists
grep -n "interface IAuditDbContext" src/Shared/Dhadgar.ServiceDefaults/Audit/*.cs
```

## Success Criteria

- [ ] All audit files compile without errors
- [ ] ApiAuditRecord has all required fields: timestamp, user ID, tenant ID, HTTP method, path, resource ID, resource type, status code, duration, correlation ID, trace ID
- [ ] AuditQueue uses System.Threading.Channels with bounded capacity
- [ ] AuditMiddleware skips unauthenticated requests and health endpoints
- [ ] AuditWriterService batch-writes without blocking request thread
- [ ] AuditCleanupService configured for 90-day retention
- [ ] IAuditDbContext interface allows services to plug in their own DbContext

## Notes

- The audit infrastructure is GENERIC - services provide their own DbContext that implements IAuditDbContext
- This follows database-per-service pattern from CLAUDE.md
- The middleware does NOT create the DbContext - it only queues events
- Background services use IServiceScopeFactory to get scoped DbContext
- Records lost on crash is acceptable (documented in research as known tradeoff)

## Output

After completion, create `.planning/phases/03-audit-system/03-01-SUMMARY.md`
