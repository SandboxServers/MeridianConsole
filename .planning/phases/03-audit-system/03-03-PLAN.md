---
phase: 03-audit-system
plan: 03-03
title: Integration Tests and Verification
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - tests/Dhadgar.Servers.Tests/Audit/AuditIntegrationTests.cs
  - tests/Dhadgar.ServiceDefaults.Tests/Audit/AuditMiddlewareTests.cs
  - tests/Dhadgar.ServiceDefaults.Tests/Audit/AuditQueueTests.cs
  - tests/Dhadgar.ServiceDefaults.Tests/Audit/AuditCleanupServiceTests.cs
autonomous: true

must_haves:
  truths:
    - "Authenticated requests create audit records in database"
    - "Unauthenticated requests do NOT create audit records"
    - "SQL query 'show all actions by user X in last 7 days' returns correct results"
    - "Cleanup service deletes records older than 90 days"
  artifacts:
    - path: "tests/Dhadgar.Servers.Tests/Audit/AuditIntegrationTests.cs"
      provides: "End-to-end audit tests with WebApplicationFactory"
      contains: "WebApplicationFactory"
    - path: "tests/Dhadgar.ServiceDefaults.Tests/Audit/AuditMiddlewareTests.cs"
      provides: "Unit tests for middleware behavior"
      contains: "AuditMiddleware"
    - path: "tests/Dhadgar.ServiceDefaults.Tests/Audit/AuditQueueTests.cs"
      provides: "Unit tests for channel queue"
      contains: "AuditQueue"
    - path: "tests/Dhadgar.ServiceDefaults.Tests/Audit/AuditCleanupServiceTests.cs"
      provides: "Unit tests for cleanup with TimeProvider"
      contains: "FakeTimeProvider"
  key_links:
    - from: "AuditIntegrationTests"
      to: "api_audit_records table"
      via: "EF Core query"
      pattern: "ApiAuditRecords\\.Where"
    - from: "AuditCleanupServiceTests"
      to: "TimeProvider"
      via: "FakeTimeProvider injection"
      pattern: "FakeTimeProvider"
---

# Integration Tests and Verification

## Objective

Create comprehensive tests that verify the audit system works end-to-end. This includes integration tests using WebApplicationFactory to prove authenticated requests create audit records, unit tests for individual components, and a SQL query test to verify AUDIT-03 ("supports SQL queries").

Purpose: Proves the audit system satisfies all requirements (AUDIT-01 through AUDIT-04).
Output: Test suite that validates audit behavior and serves as living documentation.

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-audit-system/03-01-SUMMARY.md
@.planning/phases/03-audit-system/03-02-SUMMARY.md
@tests/Dhadgar.Servers.Tests/
@src/Shared/Dhadgar.ServiceDefaults/Audit/

## Tasks

<task id="1" type="auto">
  <name>Create ServiceDefaults unit tests</name>
  <files>
    - tests/Dhadgar.ServiceDefaults.Tests/Audit/AuditQueueTests.cs
    - tests/Dhadgar.ServiceDefaults.Tests/Audit/AuditMiddlewareTests.cs
    - tests/Dhadgar.ServiceDefaults.Tests/Audit/AuditCleanupServiceTests.cs
  </files>
  <action>
**AuditQueueTests.cs** - Test the Channel-based queue:
```csharp
public class AuditQueueTests
{
    [Fact]
    public async Task QueueAsync_AddsRecordToChannel()
    {
        // Arrange
        var options = Options.Create(new AuditQueueOptions { Capacity = 100 });
        var queue = new AuditQueue(options);
        var record = new ApiAuditRecord { HttpMethod = "GET", Path = "/test" };

        // Act
        await queue.QueueAsync(record);

        // Assert - read it back
        var cts = new CancellationTokenSource(TimeSpan.FromSeconds(1));
        await foreach (var r in queue.ReadAllAsync(cts.Token))
        {
            Assert.Equal("/test", r.Path);
            break;
        }
    }

    [Fact]
    public async Task ReadAllAsync_ReturnsQueuedRecords()
    {
        // Test multiple records queued and read in order
    }
}
```

**AuditMiddlewareTests.cs** - Test middleware behavior:
- Test: Unauthenticated request does NOT queue audit record
- Test: Authenticated request queues audit record with correct fields
- Test: Health endpoint paths (/healthz, /livez, /readyz) are skipped
- Test: Resource ID extracted from path like /api/v1/servers/{guid}
- Test: Status code captured after response
- Use mock IAuditQueue and mock HttpContext

```csharp
public class AuditMiddlewareTests
{
    [Fact]
    public async Task InvokeAsync_UnauthenticatedRequest_DoesNotQueueRecord()
    {
        // Arrange
        var mockQueue = new Mock<IAuditQueue>();
        var middleware = new AuditMiddleware(
            next: _ => Task.CompletedTask,
            mockQueue.Object,
            Mock.Of<ILogger<AuditMiddleware>>());

        var context = new DefaultHttpContext();
        // User.Identity.IsAuthenticated is false by default

        // Act
        await middleware.InvokeAsync(context);

        // Assert
        mockQueue.Verify(q => q.QueueAsync(It.IsAny<ApiAuditRecord>(), It.IsAny<CancellationToken>()), Times.Never);
    }

    [Fact]
    public async Task InvokeAsync_AuthenticatedRequest_QueuesRecordWithCorrectFields()
    {
        // Arrange with authenticated user having sub and org_id claims
        // Assert record has UserId, TenantId, HttpMethod, Path, StatusCode
    }

    [Fact]
    public async Task InvokeAsync_HealthEndpoint_DoesNotQueueRecord()
    {
        // Test /healthz, /livez, /readyz paths are skipped even if authenticated
    }

    [Fact]
    public async Task InvokeAsync_ExtractsResourceIdFromPath()
    {
        // Test path like /api/v1/servers/12345678-1234-1234-1234-123456789012
        // Assert ResourceId and ResourceType are extracted
    }
}
```

**AuditCleanupServiceTests.cs** - Test cleanup with FakeTimeProvider:
```csharp
public class AuditCleanupServiceTests
{
    [Fact]
    public async Task ExecuteAsync_DeletesRecordsOlderThanRetentionPeriod()
    {
        // Use FakeTimeProvider to control time
        // Create records: some 100 days old (should delete), some 30 days old (should keep)
        // Run cleanup
        // Assert old records deleted, new records kept
    }

    [Fact]
    public async Task ExecuteAsync_WhenDisabled_DoesNothing()
    {
        // Set Enabled = false
        // Assert no database calls
    }

    [Fact]
    public async Task ExecuteAsync_BatchesLargeDeletions()
    {
        // Create more records than BatchSize
        // Assert multiple delete batches executed
    }
}
```

Note: Use `Microsoft.Extensions.Time.Testing.FakeTimeProvider` for time control (available in .NET 8+).
  </action>
  <verify>
```bash
dotnet test tests/Dhadgar.ServiceDefaults.Tests --filter "FullyQualifiedName~Audit"
```
  </verify>
  <done>
Unit tests exist for AuditQueue, AuditMiddleware, and AuditCleanupService. Tests cover key behaviors: unauthenticated skip, field extraction, cleanup retention.
  </done>
</task>

<task id="2" type="auto">
  <name>Create Servers integration tests</name>
  <files>
    - tests/Dhadgar.Servers.Tests/Audit/AuditIntegrationTests.cs
  </files>
  <action>
Create integration tests using WebApplicationFactory to test the full audit flow.

**AuditIntegrationTests.cs**:
```csharp
public class AuditIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly WebApplicationFactory<Program> _factory;

    public AuditIntegrationTests(WebApplicationFactory<Program> factory)
    {
        _factory = factory.WithWebHostBuilder(builder =>
        {
            builder.ConfigureServices(services =>
            {
                // Replace PostgreSQL with in-memory SQLite for testing
                services.RemoveAll<DbContextOptions<ServersDbContext>>();
                services.AddDbContext<ServersDbContext>(options =>
                    options.UseInMemoryDatabase("AuditTests"));

                // Add test authentication that creates authenticated user
                services.AddAuthentication("Test")
                    .AddScheme<AuthenticationSchemeOptions, TestAuthHandler>("Test", null);
            });
        });
    }

    [Fact]
    public async Task AuthenticatedRequest_CreatesAuditRecord()
    {
        // Arrange
        var client = _factory.CreateClient();
        client.DefaultRequestHeaders.Authorization =
            new AuthenticationHeaderValue("Test");

        // Act
        var response = await client.GetAsync("/hello");

        // Assert - wait briefly for background writer
        await Task.Delay(200);

        using var scope = _factory.Services.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<ServersDbContext>();
        var record = await db.ApiAuditRecords.FirstOrDefaultAsync();

        Assert.NotNull(record);
        Assert.Equal("GET", record.HttpMethod);
        Assert.Equal("/hello", record.Path);
        Assert.Equal(200, record.StatusCode);
    }

    [Fact]
    public async Task UnauthenticatedRequest_DoesNotCreateAuditRecord()
    {
        // Arrange - no auth header
        var client = _factory.CreateClient();

        // Act
        var response = await client.GetAsync("/hello");

        // Assert
        await Task.Delay(200);

        using var scope = _factory.Services.CreateScope();
        var db = scope.ServiceProvider.GetRequiredService<ServersDbContext>();
        var count = await db.ApiAuditRecords.CountAsync();

        Assert.Equal(0, count);
    }

    [Fact]
    public async Task SqlQuery_FindsUserActionsInLast7Days()
    {
        // This test proves AUDIT-03: "SQL queries like show all actions by user X in last 7 days"

        // Arrange - create test records with known user ID
        var userId = Guid.NewGuid();
        var client = _factory.CreateClient();

        // Manually insert test data spanning different dates
        using (var scope = _factory.Services.CreateScope())
        {
            var db = scope.ServiceProvider.GetRequiredService<ServersDbContext>();

            // Record from 2 days ago (should be found)
            db.ApiAuditRecords.Add(new ApiAuditRecord
            {
                UserId = userId,
                TimestampUtc = DateTime.UtcNow.AddDays(-2),
                HttpMethod = "GET",
                Path = "/recent",
                StatusCode = 200
            });

            // Record from 10 days ago (should NOT be found)
            db.ApiAuditRecords.Add(new ApiAuditRecord
            {
                UserId = userId,
                TimestampUtc = DateTime.UtcNow.AddDays(-10),
                HttpMethod = "GET",
                Path = "/old",
                StatusCode = 200
            });

            // Record from different user (should NOT be found)
            db.ApiAuditRecords.Add(new ApiAuditRecord
            {
                UserId = Guid.NewGuid(),
                TimestampUtc = DateTime.UtcNow.AddDays(-1),
                HttpMethod = "GET",
                Path = "/other-user",
                StatusCode = 200
            });

            await db.SaveChangesAsync();
        }

        // Act - query for user's actions in last 7 days
        var sevenDaysAgo = DateTime.UtcNow.AddDays(-7);

        using (var scope = _factory.Services.CreateScope())
        {
            var db = scope.ServiceProvider.GetRequiredService<ServersDbContext>();

            var records = await db.ApiAuditRecords
                .Where(r => r.UserId == userId && r.TimestampUtc >= sevenDaysAgo)
                .OrderByDescending(r => r.TimestampUtc)
                .ToListAsync();

            // Assert
            Assert.Single(records);
            Assert.Equal("/recent", records[0].Path);
        }
    }
}

// Test authentication handler
public class TestAuthHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    public TestAuthHandler(
        IOptionsMonitor<AuthenticationSchemeOptions> options,
        ILoggerFactory logger,
        UrlEncoder encoder)
        : base(options, logger, encoder) { }

    protected override Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var claims = new[]
        {
            new Claim("sub", Guid.NewGuid().ToString()),
            new Claim("org_id", Guid.NewGuid().ToString()),
        };
        var identity = new ClaimsIdentity(claims, "Test");
        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, "Test");

        return Task.FromResult(AuthenticateResult.Success(ticket));
    }
}
```

Add necessary package references to test project if not present:
- Microsoft.AspNetCore.Mvc.Testing
- Microsoft.EntityFrameworkCore.InMemory
  </action>
  <verify>
```bash
dotnet test tests/Dhadgar.Servers.Tests --filter "FullyQualifiedName~Audit"
```
  </verify>
  <done>
Integration tests verify authenticated requests create audit records, unauthenticated requests don't, and SQL queries work as expected.
  </done>
</task>

<task id="3" type="auto">
  <name>Verify full system with Docker</name>
  <files>None (verification only)</files>
  <action>
Run the full system with Docker Compose and verify audit works end-to-end.

1. Start infrastructure:
```bash
docker compose -f deploy/compose/docker-compose.dev.yml up -d
```

2. Start Servers service:
```bash
dotnet run --project src/Dhadgar.Servers
```

3. Make test requests (note: without auth, records won't be created - this is expected):
```bash
curl http://localhost:5000/hello
curl http://localhost:5000/healthz
```

4. Check database for audit records:
```bash
docker exec -it dhadgar-postgres psql -U dhadgar -d dhadgar -c "SELECT * FROM api_audit_records;"
```

Expected: No records (because no authentication is configured yet). This confirms the middleware correctly skips unauthenticated requests.

5. Verify the table structure:
```bash
docker exec -it dhadgar-postgres psql -U dhadgar -d dhadgar -c "\\d api_audit_records"
```

Expected: Table with all columns and correct types.

6. Verify indexes:
```bash
docker exec -it dhadgar-postgres psql -U dhadgar -d dhadgar -c "\\di *audit*"
```

Expected: ix_audit_user_time, ix_audit_tenant_time, ix_audit_timestamp, ix_audit_resource_time

7. Test the SQL query pattern from AUDIT-03:
```sql
-- Insert a test record manually
INSERT INTO api_audit_records (id, timestamp_utc, user_id, tenant_id, http_method, path, status_code, duration_ms)
VALUES (gen_random_uuid(), NOW(), 'a1111111-1111-1111-1111-111111111111', 'b2222222-2222-2222-2222-222222222222', 'GET', '/test', 200, 50);

-- Query: "show all actions by user X in last 7 days"
SELECT * FROM api_audit_records
WHERE user_id = 'a1111111-1111-1111-1111-111111111111'
  AND timestamp_utc >= NOW() - INTERVAL '7 days'
ORDER BY timestamp_utc DESC;
```

This proves AUDIT-03 is satisfied.
  </action>
  <verify>
```bash
# All tests pass
dotnet test tests/Dhadgar.Servers.Tests --filter "FullyQualifiedName~Audit"
dotnet test tests/Dhadgar.ServiceDefaults.Tests --filter "FullyQualifiedName~Audit"

# Table exists with correct structure
docker exec -it dhadgar-postgres psql -U dhadgar -d dhadgar -c "\\d api_audit_records" | grep -q "api_audit_records"
```
  </verify>
  <done>
Full system verified: table created, indexes exist, SQL queries work, middleware skips unauthenticated requests correctly.
  </done>
</task>

## Verification

```bash
# Run all audit tests
dotnet test --filter "FullyQualifiedName~Audit"

# Verify table structure in PostgreSQL
docker exec -it dhadgar-postgres psql -U dhadgar -d dhadgar -c "\\d api_audit_records"

# Verify indexes
docker exec -it dhadgar-postgres psql -U dhadgar -d dhadgar -c "\\di *audit*"

# Test SQL query (AUDIT-03)
docker exec -it dhadgar-postgres psql -U dhadgar -d dhadgar -c "
  SELECT http_method, path, status_code, timestamp_utc
  FROM api_audit_records
  WHERE user_id = 'test-user-id'::uuid
    AND timestamp_utc >= NOW() - INTERVAL '7 days'
  ORDER BY timestamp_utc DESC
  LIMIT 10;
"
```

## Success Criteria

- [ ] AuditQueueTests pass - channel queuing works
- [ ] AuditMiddlewareTests pass - unauthenticated skip, field extraction work
- [ ] AuditCleanupServiceTests pass - 90-day retention works with FakeTimeProvider
- [ ] AuditIntegrationTests pass - full flow with WebApplicationFactory
- [ ] SQL query test proves AUDIT-03 ("show all actions by user X in last 7 days")
- [ ] Database table and indexes verified via psql

## Notes

- Integration tests use in-memory database to avoid PostgreSQL dependency in CI
- Tests use TestAuthHandler to simulate authenticated users
- The SqlQuery test directly proves AUDIT-03 requirement
- Background writer has a small delay - tests use Task.Delay(200) to allow flush
- For production testing, would need actual JWT auth configured

## Output

After completion, create `.planning/phases/03-audit-system/03-03-SUMMARY.md`
