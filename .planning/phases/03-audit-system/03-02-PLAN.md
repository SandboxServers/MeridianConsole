---
phase: 03-audit-system
plan: 03-02
title: Service Integration and Database Schema
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/Dhadgar.Servers/Data/ServersDbContext.cs
  - src/Dhadgar.Servers/Data/Configuration/ApiAuditRecordConfiguration.cs
  - src/Dhadgar.Servers/Data/Migrations/*_AddApiAuditRecords.cs
  - src/Dhadgar.Servers/Program.cs
  - src/Dhadgar.Identity/Data/IdentityDbContext.cs
  - src/Dhadgar.Identity/Data/Configuration/ApiAuditRecordConfiguration.cs
  - src/Dhadgar.Identity/Data/Migrations/*_AddApiAuditRecords.cs
  - src/Dhadgar.Identity/Program.cs
autonomous: true

must_haves:
  truths:
    - "Servers service records authenticated API calls to api_audit_records table"
    - "Identity service records authenticated API calls to api_audit_records table"
    - "Tables have indexes for user ID + timestamp queries"
    - "Middleware is wired after authentication in pipeline"
  artifacts:
    - path: "src/Dhadgar.Servers/Data/ServersDbContext.cs"
      provides: "DbSet for audit records"
      contains: "DbSet<ApiAuditRecord> ApiAuditRecords"
    - path: "src/Dhadgar.Servers/Data/Configuration/ApiAuditRecordConfiguration.cs"
      provides: "EF Core fluent configuration with indexes"
      contains: "ix_audit_user_time"
    - path: "src/Dhadgar.Identity/Data/IdentityDbContext.cs"
      provides: "DbSet for audit records"
      contains: "DbSet<ApiAuditRecord> ApiAuditRecords"
    - path: "src/Dhadgar.Identity/Data/Configuration/ApiAuditRecordConfiguration.cs"
      provides: "EF Core fluent configuration with indexes"
      contains: "ix_audit_user_time"
  key_links:
    - from: "ServersDbContext"
      to: "IAuditDbContext"
      via: "interface implementation"
      pattern: "class ServersDbContext.*IAuditDbContext"
    - from: "Program.cs (Servers)"
      to: "AddAuditInfrastructure"
      via: "DI registration"
      pattern: "AddAuditInfrastructure<ServersDbContext>"
    - from: "Program.cs (Servers)"
      to: "UseAuditMiddleware"
      via: "middleware registration"
      pattern: "UseAuditMiddleware"
---

# Service Integration and Database Schema

## Objective

Integrate the audit infrastructure into Servers and Identity pilot services. This includes implementing IAuditDbContext on their DbContexts, creating EF Core migrations for the api_audit_records table with proper indexes, and wiring the middleware after authentication.

Purpose: Makes audit system operational in two services, validating the pattern works.
Output: Both services create audit records for authenticated API requests.

## Context

@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-audit-system/03-01-SUMMARY.md
@src/Dhadgar.Servers/Data/ServersDbContext.cs
@src/Dhadgar.Servers/Program.cs
@src/Dhadgar.Identity/Data/IdentityDbContext.cs
@src/Dhadgar.Identity/Program.cs
@src/Dhadgar.Identity/Data/Configuration/AuditEventConfiguration.cs

## Tasks

<task id="1" type="auto">
  <name>Integrate audit into Servers service</name>
  <files>
    - src/Dhadgar.Servers/Data/ServersDbContext.cs
    - src/Dhadgar.Servers/Data/Configuration/ApiAuditRecordConfiguration.cs
    - src/Dhadgar.Servers/Program.cs
  </files>
  <action>
**ServersDbContext.cs** - Implement IAuditDbContext:
1. Add `using Dhadgar.ServiceDefaults.Audit;`
2. Change class declaration to: `public sealed class ServersDbContext : DbContext, IAuditDbContext`
3. Add property: `public DbSet<ApiAuditRecord> ApiAuditRecords => Set<ApiAuditRecord>();`
4. In `OnModelCreating`, add: `modelBuilder.ApplyConfiguration(new ApiAuditRecordConfiguration());`

**ApiAuditRecordConfiguration.cs** - Create EF Core fluent configuration:
```csharp
public sealed class ApiAuditRecordConfiguration : IEntityTypeConfiguration<ApiAuditRecord>
{
    public void Configure(EntityTypeBuilder<ApiAuditRecord> builder)
    {
        builder.ToTable("api_audit_records");
        builder.HasKey(e => e.Id);

        // Primary query patterns with composite indexes
        builder.HasIndex(e => new { e.UserId, e.TimestampUtc })
            .HasDatabaseName("ix_audit_user_time")
            .IsDescending(false, true);

        builder.HasIndex(e => new { e.TenantId, e.TimestampUtc })
            .HasDatabaseName("ix_audit_tenant_time")
            .IsDescending(false, true);

        // Cleanup index (90-day retention)
        builder.HasIndex(e => e.TimestampUtc)
            .HasDatabaseName("ix_audit_timestamp");

        // Resource lookup
        builder.HasIndex(e => new { e.ResourceType, e.ResourceId, e.TimestampUtc })
            .HasDatabaseName("ix_audit_resource_time")
            .IsDescending(false, false, true);
    }
}
```

**Program.cs** - Wire audit infrastructure:
1. Add `using Dhadgar.ServiceDefaults.Audit;`
2. After `AddDhadgarLogging()`, add:
   ```csharp
   // Audit infrastructure for compliance logging
   builder.Services.AddAuditInfrastructure<ServersDbContext>();
   ```
3. After `UseAuthorization()` (or after auth middleware setup), add:
   ```csharp
   // Audit middleware - MUST run after authentication
   app.UseAuditMiddleware();
   ```

Note: Servers currently doesn't have UseAuthentication/UseAuthorization. Add a comment that audit middleware runs here and will capture authenticated requests once auth is added. For now it will skip all requests (which is correct behavior).
  </action>
  <verify>
```bash
dotnet build src/Dhadgar.Servers
```
  </verify>
  <done>
ServersDbContext implements IAuditDbContext. ApiAuditRecordConfiguration defines table and indexes. Program.cs registers audit services and middleware.
  </done>
</task>

<task id="2" type="auto">
  <name>Integrate audit into Identity service</name>
  <files>
    - src/Dhadgar.Identity/Data/IdentityDbContext.cs
    - src/Dhadgar.Identity/Data/Configuration/ApiAuditRecordConfiguration.cs
    - src/Dhadgar.Identity/Program.cs
  </files>
  <action>
**IdentityDbContext.cs** - Implement IAuditDbContext:
1. Add `using Dhadgar.ServiceDefaults.Audit;`
2. Change class declaration to implement IAuditDbContext: `public sealed class IdentityDbContext : DbContext, IAuditDbContext`
3. Add property: `public DbSet<ApiAuditRecord> ApiAuditRecords => Set<ApiAuditRecord>();`
4. In `OnModelCreating`, add: `modelBuilder.ApplyConfiguration(new ApiAuditRecordConfiguration());`

Note: Identity already has `AuditEvent` for domain events (user.created, role.assigned). `ApiAuditRecord` is different - it's for HTTP request auditing. Both coexist.

**ApiAuditRecordConfiguration.cs** - Create in Data/Configuration folder:
Same configuration as Servers (copy the pattern). Table name `api_audit_records` keeps it distinct from existing `audit_events` table.

**Program.cs** - Wire audit infrastructure:
1. Add `using Dhadgar.ServiceDefaults.Audit;`
2. After `AddDhadgarLogging()`, add:
   ```csharp
   // API audit infrastructure for compliance logging (separate from domain AuditEvents)
   builder.Services.AddAuditInfrastructure<IdentityDbContext>();
   ```
3. Identity likely has authentication configured. Find where auth middleware is, and add AFTER it:
   ```csharp
   // Audit middleware - captures authenticated API requests
   app.UseAuditMiddleware();
   ```

If Identity doesn't have auth yet, add the same comment as Servers about future auth.
  </action>
  <verify>
```bash
dotnet build src/Dhadgar.Identity
```
  </verify>
  <done>
IdentityDbContext implements IAuditDbContext with ApiAuditRecords DbSet. Program.cs registers audit services and middleware.
  </done>
</task>

<task id="3" type="auto">
  <name>Create EF Core migrations</name>
  <files>
    - src/Dhadgar.Servers/Data/Migrations/*_AddApiAuditRecords.cs
    - src/Dhadgar.Identity/Data/Migrations/*_AddApiAuditRecords.cs
  </files>
  <action>
Create migrations for both services to add the api_audit_records table.

**Servers migration:**
```bash
dotnet ef migrations add AddApiAuditRecords \
  --project src/Dhadgar.Servers \
  --startup-project src/Dhadgar.Servers \
  --output-dir Data/Migrations
```

**Identity migration:**
```bash
dotnet ef migrations add AddApiAuditRecords \
  --project src/Dhadgar.Identity \
  --startup-project src/Dhadgar.Identity \
  --output-dir Data/Migrations
```

After generating, review the migrations to ensure they create:
- `api_audit_records` table with all columns
- `ix_audit_user_time` index
- `ix_audit_tenant_time` index
- `ix_audit_timestamp` index
- `ix_audit_resource_time` index

The column types should be:
- id: uuid (primary key)
- timestamp_utc: timestamp with time zone
- user_id: uuid (nullable)
- tenant_id: uuid (nullable)
- http_method: varchar(10)
- path: varchar(500)
- resource_id: uuid (nullable)
- resource_type: varchar(50) (nullable)
- status_code: integer
- duration_ms: bigint
- client_ip: varchar(45) (nullable)
- user_agent: varchar(256) (nullable)
- correlation_id: varchar(64) (nullable)
- trace_id: varchar(32) (nullable)
- service_name: varchar(50) (nullable)
  </action>
  <verify>
```bash
# Verify migrations were created
ls src/Dhadgar.Servers/Data/Migrations/*AddApiAuditRecords*
ls src/Dhadgar.Identity/Data/Migrations/*AddApiAuditRecords*

# Build to ensure migrations compile
dotnet build src/Dhadgar.Servers
dotnet build src/Dhadgar.Identity
```
  </verify>
  <done>
Migrations exist for both services. Tables will have correct schema and indexes when applied.
  </done>
</task>

## Verification

```bash
# Build both services
dotnet build src/Dhadgar.Servers
dotnet build src/Dhadgar.Identity

# Start infrastructure
docker compose -f deploy/compose/docker-compose.dev.yml up -d

# Apply migrations (dev mode auto-applies, or run manually)
dotnet ef database update --project src/Dhadgar.Servers --startup-project src/Dhadgar.Servers
dotnet ef database update --project src/Dhadgar.Identity --startup-project src/Dhadgar.Identity

# Verify tables exist in PostgreSQL
docker exec -it dhadgar-postgres psql -U dhadgar -d dhadgar -c "\\dt *audit*"
# Should show: api_audit_records

# Verify indexes
docker exec -it dhadgar-postgres psql -U dhadgar -d dhadgar -c "\\di *audit*"
# Should show: ix_audit_user_time, ix_audit_tenant_time, ix_audit_timestamp, ix_audit_resource_time
```

## Success Criteria

- [ ] ServersDbContext implements IAuditDbContext
- [ ] IdentityDbContext implements IAuditDbContext
- [ ] Both services have ApiAuditRecordConfiguration with proper indexes
- [ ] Migrations created for both services
- [ ] Program.cs in both services calls AddAuditInfrastructure and UseAuditMiddleware
- [ ] Database tables created with correct schema when migrations applied

## Notes

- Identity has TWO audit tables now: `audit_events` (domain events like user.created) and `api_audit_records` (HTTP request audit). This is intentional - they serve different purposes.
- Since neither service has authentication fully wired yet, audit middleware will skip all requests. This is correct behavior per AUDIT-01 ("authenticated API calls").
- To test the full flow, you'd need to add a test endpoint that accepts a fake authenticated user.
- Migrations auto-apply in Development mode, so starting the services with docker-compose will create the tables.

## Output

After completion, create `.planning/phases/03-audit-system/03-02-SUMMARY.md`
