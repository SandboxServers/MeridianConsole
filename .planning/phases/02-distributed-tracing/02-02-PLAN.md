---
phase: 02-distributed-tracing
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/Dhadgar.Servers/Program.cs
  - src/Dhadgar.Identity/Program.cs
autonomous: true

must_haves:
  truths:
    - "EF Core queries from Servers service appear as spans in distributed traces"
    - "EF Core queries from Identity service appear as spans in distributed traces"
    - "Redis operations from Identity service appear as spans in distributed traces"
    - "Spans include db.system and db.operation tags"
  artifacts:
    - path: "src/Dhadgar.Servers/Program.cs"
      provides: "Servers service with AddDhadgarTracing() and EF Core spans"
      contains: "AddDhadgarTracing"
    - path: "src/Dhadgar.Identity/Program.cs"
      provides: "Identity service with EF Core and Redis tracing"
      contains: "AddRedisInstrumentation"
  key_links:
    - from: "src/Dhadgar.Servers/Program.cs"
      to: "src/Shared/Dhadgar.ServiceDefaults/Tracing/TracingExtensions.cs"
      via: "AddDhadgarTracing() call"
      pattern: "AddDhadgarTracing"
    - from: "src/Dhadgar.Identity/Program.cs"
      to: "IConnectionMultiplexer"
      via: "Redis instrumentation resolves multiplexer from DI"
      pattern: "AddRedisInstrumentation"
---

<objective>
Wire EF Core and Redis instrumentation into pilot services (Servers and Identity) using the centralized tracing infrastructure.

Purpose: Apply the tracing infrastructure from Plan 01 to real services (TRACE-01, TRACE-02). Servers is a typical database-backed service; Identity also uses Redis for token replay storage. This validates the instrumentation approach before rolling out to remaining services.

Output: Updated Program.cs files for Servers and Identity services using AddDhadgarTracing(), with EF Core and Redis spans appearing in distributed traces.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-distributed-tracing/02-RESEARCH.md

# Prior plan output (tracing infrastructure)
@.planning/phases/02-distributed-tracing/02-01-SUMMARY.md

# Files to modify
@src/Dhadgar.Servers/Program.cs
@src/Dhadgar.Identity/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire tracing to Servers service</name>
  <files>
    - src/Dhadgar.Servers/Program.cs
  </files>
  <action>
    1. Add using statement:
       ```csharp
       using Dhadgar.ServiceDefaults.Tracing;
       ```

    2. Replace the existing OpenTelemetry configuration block (WithTracing/WithMetrics) with:
       ```csharp
       // Add centralized tracing with EF Core instrumentation
       builder.Services.AddDhadgarTracing(builder.Configuration, "Dhadgar.Servers");
       ```

    3. Keep the existing metrics configuration (WithMetrics block) as-is since AddDhadgarTracing() only handles tracing, not metrics.

    4. Remove redundant OpenTelemetry setup code that's now handled by AddDhadgarTracing():
       - Remove duplicate otlpEndpoint parsing
       - Remove duplicate resourceBuilder creation
       - Remove the separate .WithTracing() block
       - Keep the .WithMetrics() block (metrics are not centralized yet)

    5. The final OpenTelemetry configuration should look like:
       ```csharp
       // Tracing (centralized)
       builder.Services.AddDhadgarTracing(builder.Configuration, "Dhadgar.Servers");

       // Metrics (keep existing)
       var otlpEndpoint = builder.Configuration["OpenTelemetry:OtlpEndpoint"];
       // ... existing metrics code ...
       ```

    Note: The AddDhadgarTracing() method internally handles OTLP endpoint configuration and EF Core instrumentation.
  </action>
  <verify>
    Run: `dotnet build src/Dhadgar.Servers`
    Expected: Build succeeds

    Run with OTLP endpoint (optional local verification):
    ```bash
    dotnet user-secrets set "OpenTelemetry:OtlpEndpoint" "http://localhost:4317" --project src/Dhadgar.Servers
    dotnet run --project src/Dhadgar.Servers
    ```
    Then make a request and check Jaeger/Grafana Tempo for spans.
  </verify>
  <done>
    - Servers/Program.cs calls AddDhadgarTracing()
    - EF Core instrumentation is active (queries will produce spans)
    - Existing metrics configuration remains intact
    - Service builds and runs successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire tracing with Redis to Identity service</name>
  <files>
    - src/Dhadgar.Identity/Program.cs
  </files>
  <action>
    1. Add using statement:
       ```csharp
       using Dhadgar.ServiceDefaults.Tracing;
       ```

    2. Locate the existing OpenTelemetry configuration (around line 751-779) and replace the .WithTracing() block with AddDhadgarTracing() that includes Redis:
       ```csharp
       // Add centralized tracing with EF Core and Redis instrumentation
       builder.Services.AddDhadgarTracing(
           builder.Configuration,
           "Dhadgar.Identity",
           tracing =>
           {
               // Add Redis instrumentation - resolves IConnectionMultiplexer from DI
               tracing.AddRedisInstrumentation();
           });
       ```

    3. IMPORTANT: The AddDhadgarTracing() call MUST come AFTER the IConnectionMultiplexer registration (around line 102-111):
       ```csharp
       builder.Services.AddSingleton<IConnectionMultiplexer>(_ =>
       {
           // existing Redis connection code
       });

       // After Redis registration, add tracing
       builder.Services.AddDhadgarTracing(
           builder.Configuration,
           "Dhadgar.Identity",
           tracing => tracing.AddRedisInstrumentation());
       ```

    4. Keep the existing metrics configuration (.WithMetrics block) as-is.

    5. Remove the old .WithTracing() block that will be replaced.

    6. The Identity service has complex startup - ensure the tracing registration is placed logically after Redis but before the app.Build() call.
  </action>
  <verify>
    Run: `dotnet build src/Dhadgar.Identity`
    Expected: Build succeeds

    Run with OTLP endpoint (optional local verification):
    ```bash
    dotnet user-secrets set "OpenTelemetry:OtlpEndpoint" "http://localhost:4317" --project src/Dhadgar.Identity
    # Start local infrastructure first: docker compose -f deploy/compose/docker-compose.dev.yml up -d
    dotnet run --project src/Dhadgar.Identity
    ```
    Then make requests and verify:
    - EF Core spans appear for database queries
    - Redis spans appear for cache operations (token replay checks)
  </verify>
  <done>
    - Identity/Program.cs calls AddDhadgarTracing() with Redis callback
    - Redis instrumentation is active (operations will produce spans)
    - EF Core instrumentation is active (queries will produce spans)
    - Service builds and runs successfully
    - Redis registration comes before tracing registration
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
   ```bash
   dotnet build src/Dhadgar.Servers
   dotnet build src/Dhadgar.Identity
   ```
   Expected: Both builds succeed with 0 errors

2. Tracing configuration verification:
   ```bash
   grep "AddDhadgarTracing" src/Dhadgar.Servers/Program.cs
   grep "AddDhadgarTracing" src/Dhadgar.Identity/Program.cs
   grep "AddRedisInstrumentation" src/Dhadgar.Identity/Program.cs
   ```
   Expected: AddDhadgarTracing calls present in both services, Redis instrumentation in Identity

3. Integration test (optional, requires local infrastructure):
   ```bash
   docker compose -f deploy/compose/docker-compose.dev.yml up -d
   dotnet run --project src/Dhadgar.Servers &
   curl http://localhost:5000/healthz
   # Check http://localhost:16686 (Jaeger) or http://localhost:3000 (Grafana) for spans
   ```
</verification>

<success_criteria>
1. Servers service uses AddDhadgarTracing() and builds successfully
2. Identity service uses AddDhadgarTracing() with Redis instrumentation and builds successfully
3. Both services maintain existing functionality (no regression)
4. When running with OTLP endpoint, EF Core queries produce spans
5. When running with OTLP endpoint, Redis operations produce spans in Identity
</success_criteria>

<output>
After completion, create `.planning/phases/02-distributed-tracing/02-02-SUMMARY.md`
</output>
