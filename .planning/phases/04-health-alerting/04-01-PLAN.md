---
phase: 04-health-alerting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Directory.Packages.props
  - src/Shared/Dhadgar.ServiceDefaults/Dhadgar.ServiceDefaults.csproj
  - src/Shared/Dhadgar.ServiceDefaults/Health/HealthCheckDependencies.cs
  - src/Shared/Dhadgar.ServiceDefaults/ServiceDefaultsExtensions.cs
  - src/Dhadgar.Servers/Program.cs
  - src/Dhadgar.Notifications/Program.cs
autonomous: true

must_haves:
  truths:
    - "Database-backed services expose /healthz/ready that fails if PostgreSQL unreachable"
    - "Services declare their dependencies via flags enum"
    - "/healthz/live returns healthy without checking external dependencies"
    - "/healthz/ready runs dependency checks with proper timeouts"
  artifacts:
    - path: "src/Shared/Dhadgar.ServiceDefaults/Health/HealthCheckDependencies.cs"
      provides: "Flags enum for service dependencies"
      contains: "[Flags]"
    - path: "src/Shared/Dhadgar.ServiceDefaults/ServiceDefaultsExtensions.cs"
      provides: "Extended AddDhadgarServiceDefaults with dependency checks"
      exports: ["AddDhadgarServiceDefaults"]
  key_links:
    - from: "src/Dhadgar.Servers/Program.cs"
      to: "ServiceDefaultsExtensions"
      via: "AddDhadgarServiceDefaults with Postgres flag"
      pattern: "HealthCheckDependencies\\.Postgres"
    - from: "AspNetCore.HealthChecks.NpgSql"
      to: "/healthz/ready endpoint"
      via: "health check registration with ready tag"
      pattern: "AddNpgSql.*tags.*ready"
---

<objective>
Add health check infrastructure with PostgreSQL, Redis, and RabbitMQ dependency checks.

Purpose: Enable Kubernetes to differentiate between crashed services (liveness) and services with unavailable dependencies (readiness). This is critical for proper pod scheduling and preventing cascading failures.

Output: Services can declare their dependencies via flags and get automatic health check registration with proper timeouts and Kubernetes-compatible tagging.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-health-alerting/04-RESEARCH.md

# Existing implementation patterns
@src/Shared/Dhadgar.ServiceDefaults/ServiceDefaultsExtensions.cs
@src/Dhadgar.Identity/Readiness/IdentityReadinessCheck.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add health check packages to central package management</name>
  <files>Directory.Packages.props, src/Shared/Dhadgar.ServiceDefaults/Dhadgar.ServiceDefaults.csproj</files>
  <action>
Add the following package versions to Directory.Packages.props in the Data section (after the existing packages):

```xml
<!-- Health Checks -->
<PackageVersion Include="AspNetCore.HealthChecks.NpgSql" Version="9.0.0" />
<PackageVersion Include="AspNetCore.HealthChecks.Redis" Version="9.0.0" />
<PackageVersion Include="AspNetCore.HealthChecks.Rabbitmq" Version="9.0.0" />
```

Then add PackageReference entries (without versions) to Dhadgar.ServiceDefaults.csproj:

```xml
<PackageReference Include="AspNetCore.HealthChecks.NpgSql" />
<PackageReference Include="AspNetCore.HealthChecks.Redis" />
<PackageReference Include="AspNetCore.HealthChecks.Rabbitmq" />
```

Note: Do NOT add AspNetCore.HealthChecks.UI.Client - use the existing custom JSON response writer in ServiceDefaultsExtensions.cs.
  </action>
  <verify>
Run `dotnet restore src/Shared/Dhadgar.ServiceDefaults` - should complete without errors.
Run `dotnet build src/Shared/Dhadgar.ServiceDefaults` - should compile without errors.
  </verify>
  <done>Health check packages are available in ServiceDefaults for use by all services.</done>
</task>

<task type="auto">
  <name>Task 2: Create HealthCheckDependencies flags enum and extend ServiceDefaultsExtensions</name>
  <files>src/Shared/Dhadgar.ServiceDefaults/Health/HealthCheckDependencies.cs, src/Shared/Dhadgar.ServiceDefaults/ServiceDefaultsExtensions.cs</files>
  <action>
Create a new file `src/Shared/Dhadgar.ServiceDefaults/Health/HealthCheckDependencies.cs`:

```csharp
namespace Dhadgar.ServiceDefaults.Health;

/// <summary>
/// Flags indicating which external dependencies a service uses.
/// Used to register appropriate health checks for Kubernetes readiness probes.
/// </summary>
[Flags]
public enum HealthCheckDependencies
{
    /// <summary>No external dependencies (basic liveness only).</summary>
    None = 0,

    /// <summary>Service uses PostgreSQL database.</summary>
    Postgres = 1,

    /// <summary>Service uses Redis cache.</summary>
    Redis = 2,

    /// <summary>Service uses RabbitMQ messaging.</summary>
    RabbitMq = 4
}
```

Extend `ServiceDefaultsExtensions.cs` to add a new overload of AddDhadgarServiceDefaults:

1. Add using directive: `using Dhadgar.ServiceDefaults.Health;`
2. Add using directive: `using HealthChecks.NpgSql;` (for the package namespace)

3. Add a new overload:
```csharp
/// <summary>
/// Adds Dhadgar service defaults with configurable health check dependencies.
/// </summary>
/// <param name="services">The service collection to configure.</param>
/// <param name="configuration">Configuration to read connection strings from.</param>
/// <param name="dependencies">Flags indicating which dependencies to check for readiness.</param>
/// <returns>The service collection for chaining.</returns>
public static IServiceCollection AddDhadgarServiceDefaults(
    this IServiceCollection services,
    IConfiguration configuration,
    HealthCheckDependencies dependencies)
{
    var healthChecks = services.AddHealthChecks()
        .AddCheck("self", () => HealthCheckResult.Healthy(), tags: ["live"]);

    if (dependencies.HasFlag(HealthCheckDependencies.Postgres))
    {
        var connectionString = configuration.GetConnectionString("Postgres");
        if (!string.IsNullOrEmpty(connectionString))
        {
            healthChecks.AddNpgSql(
                connectionString,
                name: "postgres",
                timeout: TimeSpan.FromSeconds(3),
                tags: ["ready"]);
        }
    }

    if (dependencies.HasFlag(HealthCheckDependencies.Redis))
    {
        var connectionString = configuration["Redis:ConnectionString"];
        if (!string.IsNullOrEmpty(connectionString))
        {
            healthChecks.AddRedis(
                connectionString,
                name: "redis",
                timeout: TimeSpan.FromSeconds(2),
                tags: ["ready"]);
        }
    }

    if (dependencies.HasFlag(HealthCheckDependencies.RabbitMq))
    {
        // RabbitMQ health check uses IConnection from DI
        // Services using MassTransit should register IConnectionFactory
        var rabbitHost = configuration["RabbitMq:Host"] ?? "localhost";
        var rabbitUser = configuration["RabbitMq:Username"] ?? "dhadgar";
        var rabbitPass = configuration["RabbitMq:Password"] ?? "dhadgar";
        var connectionUri = new Uri($"amqp://{rabbitUser}:{rabbitPass}@{rabbitHost}");

        healthChecks.AddRabbitMQ(
            rabbitConnectionString: connectionUri,
            name: "rabbitmq",
            timeout: TimeSpan.FromSeconds(3),
            tags: ["ready"]);
    }

    // Register organization context for multi-tenant logging
    services.AddOrganizationContext();

    // Register source-generated request logging messages as singleton
    services.AddSingleton<RequestLoggingMessages>();

    return services;
}
```

4. Add required using at the top:
```csharp
using Microsoft.Extensions.Configuration;
```

Keep the original parameterless AddDhadgarServiceDefaults method as-is for backward compatibility.
  </action>
  <verify>
Run `dotnet build src/Shared/Dhadgar.ServiceDefaults` - should compile without errors.
  </verify>
  <done>ServiceDefaults exposes AddDhadgarServiceDefaults overload that accepts configuration and HealthCheckDependencies flags.</done>
</task>

<task type="auto">
  <name>Task 3: Wire health checks to Servers and Notifications services</name>
  <files>src/Dhadgar.Servers/Program.cs, src/Dhadgar.Notifications/Program.cs</files>
  <action>
Update Servers service (PostgreSQL-backed):

1. Add using: `using Dhadgar.ServiceDefaults.Health;`
2. Replace `builder.Services.AddDhadgarServiceDefaults();` with:
```csharp
builder.Services.AddDhadgarServiceDefaults(
    builder.Configuration,
    HealthCheckDependencies.Postgres);
```

Update Notifications service (PostgreSQL-backed):

1. Add using: `using Dhadgar.ServiceDefaults.Health;`
2. Replace `builder.Services.AddDhadgarServiceDefaults();` with:
```csharp
builder.Services.AddDhadgarServiceDefaults(
    builder.Configuration,
    HealthCheckDependencies.Postgres);
```

Note: Identity service already has custom IdentityReadinessCheck that handles both Postgres and Redis, so leave it unchanged. The custom check is already tagged with "ready".
  </action>
  <verify>
1. Run `dotnet build src/Dhadgar.Servers && dotnet build src/Dhadgar.Notifications`
2. Start the dev infrastructure: `docker compose -f deploy/compose/docker-compose.dev.yml up -d postgres`
3. Run Servers service: `dotnet run --project src/Dhadgar.Servers`
4. Test endpoints:
   - `curl http://localhost:5000/healthz` - should return JSON with postgres check status
   - `curl http://localhost:5000/livez` - should return only "self" check (no postgres)
   - `curl http://localhost:5000/readyz` - should return only "postgres" check
5. Stop postgres: `docker compose -f deploy/compose/docker-compose.dev.yml stop postgres`
6. Test again: `curl http://localhost:5000/readyz` - should return unhealthy status
7. Restart postgres: `docker compose -f deploy/compose/docker-compose.dev.yml start postgres`
  </verify>
  <done>Servers and Notifications services expose /healthz/ready that fails if PostgreSQL is unreachable, and /healthz/live that only checks process health.</done>
</task>

</tasks>

<verification>
1. `dotnet build` at solution root completes without errors
2. `dotnet test tests/Dhadgar.ServiceDefaults.Tests` passes
3. Servers service /readyz endpoint returns postgres check with "ready" tag
4. Servers service /livez endpoint does NOT include postgres check
5. When PostgreSQL is stopped, /readyz returns unhealthy, /livez still returns healthy
</verification>

<success_criteria>
- Health check packages available in ServiceDefaults
- HealthCheckDependencies flags enum exists with Postgres, Redis, RabbitMq flags
- AddDhadgarServiceDefaults(config, dependencies) overload available
- Servers service uses Postgres health check on readiness endpoint
- Notifications service uses Postgres health check on readiness endpoint
- Liveness checks remain fast (no external dependencies)
- Readiness checks have 3-second timeout
</success_criteria>

<output>
After completion, create `.planning/phases/04-health-alerting/04-01-SUMMARY.md`
</output>
