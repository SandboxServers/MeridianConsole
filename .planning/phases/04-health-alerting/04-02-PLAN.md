---
phase: 04-health-alerting
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Directory.Packages.props
  - src/Dhadgar.Notifications/Dhadgar.Notifications.csproj
  - src/Dhadgar.Notifications/Alerting/AlertMessage.cs
  - src/Dhadgar.Notifications/Alerting/IAlertDispatcher.cs
  - src/Dhadgar.Notifications/Alerting/AlertDispatcher.cs
  - src/Dhadgar.Notifications/Alerting/AlertThrottler.cs
  - src/Dhadgar.Notifications/Discord/DiscordOptions.cs
  - src/Dhadgar.Notifications/Discord/IDiscordWebhook.cs
  - src/Dhadgar.Notifications/Discord/DiscordWebhookClient.cs
  - src/Dhadgar.Notifications/Email/EmailOptions.cs
  - src/Dhadgar.Notifications/Email/IEmailSender.cs
  - src/Dhadgar.Notifications/Email/SmtpEmailSender.cs
  - src/Dhadgar.Notifications/appsettings.json
  - src/Dhadgar.Notifications/Program.cs
autonomous: true

must_haves:
  truths:
    - "Discord webhook receives alert payload with service name, message, and trace context"
    - "Email sender sends SMTP email with alert details"
    - "Alert throttling prevents duplicate alerts within 5-minute window"
    - "Alerts include service name, trace ID, and correlation ID"
  artifacts:
    - path: "src/Dhadgar.Notifications/Alerting/IAlertDispatcher.cs"
      provides: "Alert dispatch interface"
      exports: ["IAlertDispatcher", "AlertMessage"]
    - path: "src/Dhadgar.Notifications/Discord/DiscordWebhookClient.cs"
      provides: "Discord webhook HTTP client"
      min_lines: 30
    - path: "src/Dhadgar.Notifications/Email/SmtpEmailSender.cs"
      provides: "MailKit-based SMTP sender"
      min_lines: 40
  key_links:
    - from: "AlertDispatcher"
      to: "DiscordWebhookClient"
      via: "DI injection"
      pattern: "IDiscordWebhook"
    - from: "AlertDispatcher"
      to: "SmtpEmailSender"
      via: "DI injection"
      pattern: "IEmailSender"
    - from: "Program.cs"
      to: "AlertDispatcher"
      via: "DI registration"
      pattern: "AddSingleton.*IAlertDispatcher"
---

<objective>
Create alerting infrastructure with Discord webhook and email notification capabilities.

Purpose: Enable proactive notification of critical errors to operations team via Discord (for real-time alerting) and email (for audit trail and offline access). This addresses requirements ALERT-01 and ALERT-02.

Output: IAlertDispatcher service that can send alerts to Discord webhooks and SMTP email with automatic throttling to prevent alert storms.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-health-alerting/04-RESEARCH.md

# Existing notification service structure
@src/Dhadgar.Notifications/Program.cs
@src/Dhadgar.Notifications/Dhadgar.Notifications.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MailKit package and create alert message types</name>
  <files>Directory.Packages.props, src/Dhadgar.Notifications/Dhadgar.Notifications.csproj, src/Dhadgar.Notifications/Alerting/AlertMessage.cs, src/Dhadgar.Notifications/Alerting/IAlertDispatcher.cs</files>
  <action>
Add MailKit package version to Directory.Packages.props (in appropriate section):

```xml
<!-- Email -->
<PackageVersion Include="MailKit" Version="4.11.0" />
```

Add PackageReference to Dhadgar.Notifications.csproj:

```xml
<PackageReference Include="MailKit" />
```

Create `src/Dhadgar.Notifications/Alerting/AlertMessage.cs`:

```csharp
namespace Dhadgar.Notifications.Alerting;

/// <summary>
/// Severity levels for alert messages.
/// </summary>
public enum AlertSeverity
{
    /// <summary>Warning level - something unexpected happened but service continues.</summary>
    Warning,

    /// <summary>Error level - an error occurred that may affect service functionality.</summary>
    Error,

    /// <summary>Critical level - a critical error requiring immediate attention.</summary>
    Critical
}

/// <summary>
/// Represents an alert message to be dispatched to notification channels.
/// </summary>
public sealed record AlertMessage
{
    /// <summary>Gets the alert title (short summary).</summary>
    public required string Title { get; init; }

    /// <summary>Gets the detailed alert message.</summary>
    public required string Message { get; init; }

    /// <summary>Gets the severity level.</summary>
    public required AlertSeverity Severity { get; init; }

    /// <summary>Gets the service that generated the alert.</summary>
    public required string ServiceName { get; init; }

    /// <summary>Gets the trace ID for distributed tracing correlation.</summary>
    public string? TraceId { get; init; }

    /// <summary>Gets the correlation ID for request tracking.</summary>
    public string? CorrelationId { get; init; }

    /// <summary>Gets the exception type if the alert was triggered by an exception.</summary>
    public string? ExceptionType { get; init; }

    /// <summary>Gets the timestamp when the alert was created.</summary>
    public DateTimeOffset Timestamp { get; init; } = DateTimeOffset.UtcNow;

    /// <summary>Gets additional context data.</summary>
    public IReadOnlyDictionary<string, string>? AdditionalData { get; init; }
}
```

Create `src/Dhadgar.Notifications/Alerting/IAlertDispatcher.cs`:

```csharp
namespace Dhadgar.Notifications.Alerting;

/// <summary>
/// Dispatches alert messages to configured notification channels (Discord, email, etc.).
/// </summary>
public interface IAlertDispatcher
{
    /// <summary>
    /// Dispatches an alert to all configured channels.
    /// </summary>
    /// <param name="alert">The alert message to dispatch.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>A task representing the async operation.</returns>
    Task DispatchAsync(AlertMessage alert, CancellationToken cancellationToken = default);
}
```
  </action>
  <verify>
Run `dotnet restore src/Dhadgar.Notifications && dotnet build src/Dhadgar.Notifications` - should complete without errors.
  </verify>
  <done>MailKit package added and core alert types (AlertMessage, AlertSeverity, IAlertDispatcher) created.</done>
</task>

<task type="auto">
  <name>Task 2: Create Discord webhook and email sender implementations</name>
  <files>src/Dhadgar.Notifications/Discord/DiscordOptions.cs, src/Dhadgar.Notifications/Discord/IDiscordWebhook.cs, src/Dhadgar.Notifications/Discord/DiscordWebhookClient.cs, src/Dhadgar.Notifications/Email/EmailOptions.cs, src/Dhadgar.Notifications/Email/IEmailSender.cs, src/Dhadgar.Notifications/Email/SmtpEmailSender.cs</files>
  <action>
Create `src/Dhadgar.Notifications/Discord/DiscordOptions.cs`:

```csharp
namespace Dhadgar.Notifications.Discord;

/// <summary>
/// Configuration options for Discord webhook integration.
/// </summary>
public sealed class DiscordOptions
{
    /// <summary>Gets or sets the Discord webhook URL.</summary>
    public string? WebhookUrl { get; set; }

    /// <summary>Gets or sets the bot username to display.</summary>
    public string Username { get; set; } = "Meridian Alerts";

    /// <summary>Gets or sets whether alerts are enabled.</summary>
    public bool Enabled { get; set; } = true;
}
```

Create `src/Dhadgar.Notifications/Discord/IDiscordWebhook.cs`:

```csharp
using Dhadgar.Notifications.Alerting;

namespace Dhadgar.Notifications.Discord;

/// <summary>
/// Sends alert messages to Discord via webhook.
/// </summary>
public interface IDiscordWebhook
{
    /// <summary>
    /// Sends an alert to the configured Discord webhook.
    /// </summary>
    Task SendAlertAsync(AlertMessage alert, CancellationToken cancellationToken = default);
}
```

Create `src/Dhadgar.Notifications/Discord/DiscordWebhookClient.cs`:

```csharp
using System.Text;
using System.Text.Json;
using Dhadgar.Notifications.Alerting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Dhadgar.Notifications.Discord;

/// <summary>
/// Sends alerts to Discord via webhook API.
/// </summary>
public sealed class DiscordWebhookClient : IDiscordWebhook
{
    private readonly HttpClient _httpClient;
    private readonly DiscordOptions _options;
    private readonly ILogger<DiscordWebhookClient> _logger;

    public DiscordWebhookClient(
        HttpClient httpClient,
        IOptions<DiscordOptions> options,
        ILogger<DiscordWebhookClient> logger)
    {
        _httpClient = httpClient;
        _options = options.Value;
        _logger = logger;
    }

    public async Task SendAlertAsync(AlertMessage alert, CancellationToken cancellationToken = default)
    {
        if (!_options.Enabled || string.IsNullOrWhiteSpace(_options.WebhookUrl))
        {
            _logger.LogDebug("Discord alerting disabled or webhook URL not configured");
            return;
        }

        var color = alert.Severity switch
        {
            AlertSeverity.Critical => 0xFF0000, // Red
            AlertSeverity.Error => 0xFFA500,    // Orange
            AlertSeverity.Warning => 0xFFFF00,  // Yellow
            _ => 0x808080                       // Gray
        };

        var fields = new List<object>
        {
            new { name = "Service", value = alert.ServiceName, inline = true },
            new { name = "Severity", value = alert.Severity.ToString(), inline = true }
        };

        if (!string.IsNullOrWhiteSpace(alert.TraceId))
        {
            fields.Add(new { name = "TraceId", value = $"`{alert.TraceId}`", inline = false });
        }

        if (!string.IsNullOrWhiteSpace(alert.CorrelationId))
        {
            fields.Add(new { name = "CorrelationId", value = $"`{alert.CorrelationId}`", inline = false });
        }

        if (!string.IsNullOrWhiteSpace(alert.ExceptionType))
        {
            fields.Add(new { name = "Exception", value = alert.ExceptionType, inline = true });
        }

        var payload = new
        {
            username = _options.Username,
            embeds = new[]
            {
                new
                {
                    title = alert.Title,
                    description = TruncateMessage(alert.Message, 2048),
                    color,
                    timestamp = alert.Timestamp.ToString("O"),
                    fields,
                    footer = new { text = $"Meridian Console | {alert.Timestamp:yyyy-MM-dd HH:mm:ss} UTC" }
                }
            }
        };

        var json = JsonSerializer.Serialize(payload);
        var content = new StringContent(json, Encoding.UTF8, "application/json");

        try
        {
            var response = await _httpClient.PostAsync(_options.WebhookUrl, content, cancellationToken);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = await response.Content.ReadAsStringAsync(cancellationToken);
                _logger.LogWarning(
                    "Discord webhook returned {StatusCode}: {Response}",
                    response.StatusCode,
                    responseBody);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to send Discord webhook alert");
        }
    }

    private static string TruncateMessage(string message, int maxLength)
    {
        if (string.IsNullOrEmpty(message) || message.Length <= maxLength)
            return message;

        return string.Concat(message.AsSpan(0, maxLength - 3), "...");
    }
}
```

Create `src/Dhadgar.Notifications/Email/EmailOptions.cs`:

```csharp
namespace Dhadgar.Notifications.Email;

/// <summary>
/// Configuration options for SMTP email sending.
/// </summary>
public sealed class EmailOptions
{
    /// <summary>Gets or sets the SMTP server hostname.</summary>
    public string SmtpHost { get; set; } = "localhost";

    /// <summary>Gets or sets the SMTP server port.</summary>
    public int SmtpPort { get; set; } = 587;

    /// <summary>Gets or sets the SMTP username for authentication.</summary>
    public string? SmtpUsername { get; set; }

    /// <summary>Gets or sets the SMTP password for authentication.</summary>
    public string? SmtpPassword { get; set; }

    /// <summary>Gets or sets whether to use TLS/SSL.</summary>
    public bool UseTls { get; set; } = true;

    /// <summary>Gets or sets the sender display name.</summary>
    public string SenderName { get; set; } = "Meridian Alerts";

    /// <summary>Gets or sets the sender email address.</summary>
    public string SenderEmail { get; set; } = "alerts@meridian.local";

    /// <summary>Gets or sets the alert recipient email address(es), comma-separated.</summary>
    public string AlertRecipients { get; set; } = "";

    /// <summary>Gets or sets whether email alerts are enabled.</summary>
    public bool Enabled { get; set; } = true;
}
```

Create `src/Dhadgar.Notifications/Email/IEmailSender.cs`:

```csharp
using Dhadgar.Notifications.Alerting;

namespace Dhadgar.Notifications.Email;

/// <summary>
/// Sends alert emails via SMTP.
/// </summary>
public interface IEmailSender
{
    /// <summary>
    /// Sends an alert email to configured recipients.
    /// </summary>
    Task SendAlertEmailAsync(AlertMessage alert, CancellationToken cancellationToken = default);
}
```

Create `src/Dhadgar.Notifications/Email/SmtpEmailSender.cs`:

```csharp
using Dhadgar.Notifications.Alerting;
using MailKit.Net.Smtp;
using MailKit.Security;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using MimeKit;

namespace Dhadgar.Notifications.Email;

/// <summary>
/// Sends alert emails using MailKit SMTP client.
/// </summary>
public sealed class SmtpEmailSender : IEmailSender
{
    private readonly EmailOptions _options;
    private readonly ILogger<SmtpEmailSender> _logger;

    public SmtpEmailSender(IOptions<EmailOptions> options, ILogger<SmtpEmailSender> logger)
    {
        _options = options.Value;
        _logger = logger;
    }

    public async Task SendAlertEmailAsync(AlertMessage alert, CancellationToken cancellationToken = default)
    {
        if (!_options.Enabled || string.IsNullOrWhiteSpace(_options.AlertRecipients))
        {
            _logger.LogDebug("Email alerting disabled or no recipients configured");
            return;
        }

        var severityLabel = alert.Severity.ToString().ToUpperInvariant();
        var subject = $"[{severityLabel}] {alert.ServiceName}: {alert.Title}";

        var message = new MimeMessage();
        message.From.Add(new MailboxAddress(_options.SenderName, _options.SenderEmail));

        foreach (var recipient in _options.AlertRecipients.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries))
        {
            message.To.Add(new MailboxAddress(null, recipient));
        }

        message.Subject = subject;

        var htmlBody = BuildHtmlBody(alert);
        message.Body = new TextPart("html") { Text = htmlBody };

        try
        {
            using var client = new SmtpClient();

            var secureSocketOptions = _options.UseTls
                ? SecureSocketOptions.StartTls
                : SecureSocketOptions.None;

            await client.ConnectAsync(
                _options.SmtpHost,
                _options.SmtpPort,
                secureSocketOptions,
                cancellationToken);

            if (!string.IsNullOrWhiteSpace(_options.SmtpUsername))
            {
                await client.AuthenticateAsync(
                    _options.SmtpUsername,
                    _options.SmtpPassword,
                    cancellationToken);
            }

            await client.SendAsync(message, cancellationToken);
            await client.DisconnectAsync(true, cancellationToken);

            _logger.LogInformation("Alert email sent: {Subject}", subject);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to send alert email: {Subject}", subject);
        }
    }

    private static string BuildHtmlBody(AlertMessage alert)
    {
        var severityColor = alert.Severity switch
        {
            AlertSeverity.Critical => "#dc3545",
            AlertSeverity.Error => "#fd7e14",
            AlertSeverity.Warning => "#ffc107",
            _ => "#6c757d"
        };

        var additionalRows = string.Empty;
        if (alert.AdditionalData is not null)
        {
            foreach (var kvp in alert.AdditionalData)
            {
                additionalRows += $"<tr><td style=\"padding: 8px; border: 1px solid #ddd;\"><strong>{System.Net.WebUtility.HtmlEncode(kvp.Key)}</strong></td><td style=\"padding: 8px; border: 1px solid #ddd;\">{System.Net.WebUtility.HtmlEncode(kvp.Value)}</td></tr>";
            }
        }

        return $"""
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="utf-8">
                <style>
                    body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }}
                    .container {{ max-width: 600px; margin: 0 auto; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
                    .header {{ background: {severityColor}; color: white; padding: 20px; }}
                    .header h1 {{ margin: 0; font-size: 24px; }}
                    .content {{ padding: 20px; }}
                    .message {{ background: #f8f9fa; padding: 15px; border-radius: 4px; margin-bottom: 20px; white-space: pre-wrap; }}
                    table {{ width: 100%; border-collapse: collapse; }}
                    th, td {{ padding: 8px; text-align: left; border: 1px solid #ddd; }}
                    th {{ background: #f8f9fa; }}
                    .footer {{ padding: 15px 20px; background: #f8f9fa; font-size: 12px; color: #666; }}
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>{System.Net.WebUtility.HtmlEncode(alert.Title)}</h1>
                    </div>
                    <div class="content">
                        <div class="message">{System.Net.WebUtility.HtmlEncode(alert.Message)}</div>
                        <table>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Service</strong></td><td style="padding: 8px; border: 1px solid #ddd;">{System.Net.WebUtility.HtmlEncode(alert.ServiceName)}</td></tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Severity</strong></td><td style="padding: 8px; border: 1px solid #ddd;">{alert.Severity}</td></tr>
                            <tr><td style="padding: 8px; border: 1px solid #ddd;"><strong>Timestamp</strong></td><td style="padding: 8px; border: 1px solid #ddd;">{alert.Timestamp:yyyy-MM-dd HH:mm:ss} UTC</td></tr>
                            {(string.IsNullOrWhiteSpace(alert.TraceId) ? "" : $"<tr><td style=\"padding: 8px; border: 1px solid #ddd;\"><strong>Trace ID</strong></td><td style=\"padding: 8px; border: 1px solid #ddd;\"><code>{System.Net.WebUtility.HtmlEncode(alert.TraceId)}</code></td></tr>")}
                            {(string.IsNullOrWhiteSpace(alert.CorrelationId) ? "" : $"<tr><td style=\"padding: 8px; border: 1px solid #ddd;\"><strong>Correlation ID</strong></td><td style=\"padding: 8px; border: 1px solid #ddd;\"><code>{System.Net.WebUtility.HtmlEncode(alert.CorrelationId)}</code></td></tr>")}
                            {(string.IsNullOrWhiteSpace(alert.ExceptionType) ? "" : $"<tr><td style=\"padding: 8px; border: 1px solid #ddd;\"><strong>Exception</strong></td><td style=\"padding: 8px; border: 1px solid #ddd;\">{System.Net.WebUtility.HtmlEncode(alert.ExceptionType)}</td></tr>")}
                            {additionalRows}
                        </table>
                    </div>
                    <div class="footer">
                        Meridian Console Alert System
                    </div>
                </div>
            </body>
            </html>
            """;
    }
}
```
  </action>
  <verify>
Run `dotnet build src/Dhadgar.Notifications` - should compile without errors.
  </verify>
  <done>Discord webhook client and SMTP email sender implementations complete with proper error handling and logging.</done>
</task>

<task type="auto">
  <name>Task 3: Create throttled alert dispatcher and wire DI</name>
  <files>src/Dhadgar.Notifications/Alerting/AlertThrottler.cs, src/Dhadgar.Notifications/Alerting/AlertDispatcher.cs, src/Dhadgar.Notifications/appsettings.json, src/Dhadgar.Notifications/Program.cs</files>
  <action>
Create `src/Dhadgar.Notifications/Alerting/AlertThrottler.cs`:

```csharp
using System.Collections.Concurrent;

namespace Dhadgar.Notifications.Alerting;

/// <summary>
/// Throttles alerts to prevent alert storms. Uses a sliding window per alert key.
/// </summary>
public sealed class AlertThrottler
{
    private readonly ConcurrentDictionary<string, DateTimeOffset> _lastAlertTimes = new();
    private readonly TimeSpan _throttleWindow;

    /// <summary>
    /// Creates a new throttler with the specified throttle window.
    /// </summary>
    /// <param name="throttleWindow">Minimum time between duplicate alerts.</param>
    public AlertThrottler(TimeSpan throttleWindow)
    {
        _throttleWindow = throttleWindow;
    }

    /// <summary>
    /// Checks if an alert should be sent or throttled.
    /// </summary>
    /// <param name="alert">The alert to check.</param>
    /// <returns>True if alert should be sent; false if throttled.</returns>
    public bool ShouldSend(AlertMessage alert)
    {
        var key = GetAlertKey(alert);
        var now = DateTimeOffset.UtcNow;

        if (_lastAlertTimes.TryGetValue(key, out var lastTime))
        {
            if (now - lastTime < _throttleWindow)
            {
                return false; // Throttled
            }
        }

        _lastAlertTimes[key] = now;
        CleanupOldEntries(now);
        return true;
    }

    private static string GetAlertKey(AlertMessage alert)
    {
        // Key on service + title + exception type for deduplication
        return $"{alert.ServiceName}:{alert.Title}:{alert.ExceptionType ?? "none"}";
    }

    private void CleanupOldEntries(DateTimeOffset now)
    {
        // Remove entries older than 2x throttle window to prevent memory growth
        var cutoff = now - (_throttleWindow * 2);
        var keysToRemove = _lastAlertTimes
            .Where(kvp => kvp.Value < cutoff)
            .Select(kvp => kvp.Key)
            .ToList();

        foreach (var key in keysToRemove)
        {
            _lastAlertTimes.TryRemove(key, out _);
        }
    }
}
```

Create `src/Dhadgar.Notifications/Alerting/AlertDispatcher.cs`:

```csharp
using Dhadgar.Notifications.Discord;
using Dhadgar.Notifications.Email;
using Microsoft.Extensions.Logging;

namespace Dhadgar.Notifications.Alerting;

/// <summary>
/// Dispatches alerts to all configured channels with throttling.
/// </summary>
public sealed class AlertDispatcher : IAlertDispatcher
{
    private readonly IDiscordWebhook _discord;
    private readonly IEmailSender _email;
    private readonly AlertThrottler _throttler;
    private readonly ILogger<AlertDispatcher> _logger;

    public AlertDispatcher(
        IDiscordWebhook discord,
        IEmailSender email,
        AlertThrottler throttler,
        ILogger<AlertDispatcher> logger)
    {
        _discord = discord;
        _email = email;
        _throttler = throttler;
        _logger = logger;
    }

    public async Task DispatchAsync(AlertMessage alert, CancellationToken cancellationToken = default)
    {
        if (!_throttler.ShouldSend(alert))
        {
            _logger.LogDebug(
                "Alert throttled: {ServiceName} - {Title}",
                alert.ServiceName,
                alert.Title);
            return;
        }

        _logger.LogInformation(
            "Dispatching alert: {ServiceName} - {Title} ({Severity})",
            alert.ServiceName,
            alert.Title,
            alert.Severity);

        // Dispatch to all channels in parallel
        var tasks = new List<Task>
        {
            _discord.SendAlertAsync(alert, cancellationToken),
            _email.SendAlertEmailAsync(alert, cancellationToken)
        };

        await Task.WhenAll(tasks);
    }
}
```

Update `src/Dhadgar.Notifications/appsettings.json` to add alert configuration sections:

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "Postgres": "Host=localhost;Port=5432;Database=dhadgar_notifications;Username=dhadgar;Password=dhadgar"
  },
  "Discord": {
    "WebhookUrl": "",
    "Username": "Meridian Alerts",
    "Enabled": true
  },
  "Email": {
    "SmtpHost": "localhost",
    "SmtpPort": 587,
    "SmtpUsername": "",
    "SmtpPassword": "",
    "UseTls": true,
    "SenderName": "Meridian Alerts",
    "SenderEmail": "alerts@meridian.local",
    "AlertRecipients": "",
    "Enabled": true
  },
  "Alerting": {
    "ThrottleWindowMinutes": 5
  }
}
```

Update `src/Dhadgar.Notifications/Program.cs` to register all alerting services. Add after the existing service registrations:

1. Add using directives at the top:
```csharp
using Dhadgar.Notifications.Alerting;
using Dhadgar.Notifications.Discord;
using Dhadgar.Notifications.Email;
using Dhadgar.ServiceDefaults.Health;
```

2. After the DbContext registration, add:
```csharp
// Configure alerting options
builder.Services.Configure<DiscordOptions>(builder.Configuration.GetSection("Discord"));
builder.Services.Configure<EmailOptions>(builder.Configuration.GetSection("Email"));

// Register HTTP client for Discord webhook
builder.Services.AddHttpClient<IDiscordWebhook, DiscordWebhookClient>(client =>
{
    client.Timeout = TimeSpan.FromSeconds(10);
});

// Register email sender
builder.Services.AddSingleton<IEmailSender, SmtpEmailSender>();

// Register throttler with configurable window
var throttleMinutes = builder.Configuration.GetValue<int>("Alerting:ThrottleWindowMinutes", 5);
builder.Services.AddSingleton(new AlertThrottler(TimeSpan.FromMinutes(throttleMinutes)));

// Register alert dispatcher
builder.Services.AddSingleton<IAlertDispatcher, AlertDispatcher>();
```

3. Replace `builder.Services.AddDhadgarServiceDefaults();` with:
```csharp
builder.Services.AddDhadgarServiceDefaults(
    builder.Configuration,
    HealthCheckDependencies.Postgres);
```
  </action>
  <verify>
1. Run `dotnet build src/Dhadgar.Notifications` - should compile without errors
2. Run `dotnet run --project src/Dhadgar.Notifications` briefly to ensure startup doesn't fail
3. Check that no exceptions occur at startup (Discord/email will be no-ops without config)
  </verify>
  <done>Alert dispatcher with throttling is registered in DI and ready to dispatch alerts to Discord and email channels.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/Dhadgar.Notifications` compiles successfully
2. MailKit package is listed in dependencies
3. IAlertDispatcher is resolvable from DI
4. Discord webhook client handles missing configuration gracefully (logs debug, no exception)
5. Email sender handles missing configuration gracefully (logs debug, no exception)
6. AlertThrottler prevents duplicate alerts within 5-minute window
</verification>

<success_criteria>
- MailKit package version 4.11.0 in Directory.Packages.props
- AlertMessage record with Title, Message, Severity, ServiceName, TraceId, CorrelationId
- IAlertDispatcher interface defined
- DiscordWebhookClient sends embeds with color-coded severity
- SmtpEmailSender sends HTML emails via MailKit
- AlertThrottler with configurable sliding window
- AlertDispatcher wired in Program.cs with all dependencies
- Graceful degradation when Discord/email not configured
</success_criteria>

<output>
After completion, create `.planning/phases/04-health-alerting/04-02-SUMMARY.md`
</output>
