{
  "version": "v1",
  "notes": [
    "Dot schema model: identity.users (schema.table). This stays stable across SaaS (DB-per-service) and KiP (schemas in one DB).",
    "SaaS: all platform service DBs live on Platform PG cluster nodes; customer game-server DBs live on User PG cluster nodes OR BYO DB servers (we provision with network/IAM access).",
    "KiP: BYO DB server; KiP manages DB creation + migrations; BYO can be the same instance hosting the KiP database.",
    "Cross-service references are UUID soft-refs in SaaS (no cross-DB FKs). Within a service schema, FKs are normal and modeled below."
  ],
  "services": [
    {
      "key": "identity",
      "name": "Identity Service",
      "schema": "identity",
      "items": [
        {
          "id": "identity.users",
          "kind": "table",
          "details": [
            "columns:",
            "  id uuid pk default gen_random_uuid()",
            "  tenant_id uuid not null",
            "  email citext not null",
            "  display_name text not null",
            "  password_hash text null  -- null when external auth",
            "  status identity.user_status not null default 'active'",
            "  created_at timestamptz not null default now()",
            "  updated_at timestamptz not null default now()",
            "  deleted_at timestamptz null",
            "indexes:",
            "  unique (tenant_id, email) where deleted_at is null",
            "  btree (tenant_id, status)"
          ]
        },
        {
          "id": "identity.roles",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid not null, name text not null, description text null",
            "unique (tenant_id, name)"
          ]
        },
        {
          "id": "identity.user_roles",
          "kind": "table",
          "details": [
            "columns: user_id uuid fk -> identity.users(id)",
            "role_id uuid fk -> identity.roles(id)",
            "primary key (user_id, role_id)"
          ]
        },
        {
          "id": "identity.api_keys",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid not null, name text not null",
            "key_hash text not null  -- store hashed key only",
            "scopes jsonb not null default '[]'::jsonb",
            "expires_at timestamptz null, revoked_at timestamptz null",
            "created_at timestamptz not null default now()",
            "indexes: gin(scopes)"
          ]
        },
        {
          "id": "identity.sessions",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "user_id uuid fk -> identity.users(id)",
            "refresh_token_hash text not null",
            "issued_at timestamptz not null default now()",
            "expires_at timestamptz not null",
            "revoked_at timestamptz null"
          ]
        },
        {
          "id": "identity.v_active_users",
          "kind": "view",
          "details": [
            "Purpose: list active, non-deleted users per tenant",
            "Definition: select * from identity.users where deleted_at is null and status='active'"
          ]
        },
        {
          "id": "identity.fn_normalize_email",
          "kind": "function",
          "details": [
            "signature: identity.fn_normalize_email(p_email text) returns citext",
            "notes: trims + lowercases; used for deterministic uniqueness"
          ]
        },
        {
          "id": "identity.user_status",
          "kind": "enum",
          "details": [
            "values: active, invited, locked, disabled"
          ]
        }
      ],
      "relationships": [
        {
          "from": "identity.user_roles",
          "to": "identity.users",
          "label": "user_roles.user_id -> users.id"
        },
        {
          "from": "identity.user_roles",
          "to": "identity.roles",
          "label": "user_roles.role_id -> roles.id"
        },
        {
          "from": "identity.sessions",
          "to": "identity.users",
          "label": "sessions.user_id -> users.id"
        }
      ]
    },
    {
      "key": "billing",
      "name": "Billing Service",
      "schema": "billing",
      "items": [
        {
          "id": "billing.plans",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "code text not null unique",
            "name text not null, description text null",
            "price_monthly_cents int not null",
            "limits jsonb not null default '{}'::jsonb",
            "active bool not null default true",
            "indexes: gin(limits)"
          ]
        },
        {
          "id": "billing.subscriptions",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid not null",
            "plan_id uuid fk -> billing.plans(id)",
            "status billing.subscription_status not null default 'trialing'",
            "started_at timestamptz not null default now()",
            "ends_at timestamptz null",
            "cancelled_at timestamptz null",
            "metadata jsonb not null default '{}'::jsonb",
            "indexes: (tenant_id, status)"
          ]
        },
        {
          "id": "billing.invoices",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid not null",
            "period_start date not null, period_end date not null",
            "status billing.invoice_status not null default 'open'",
            "total_cents int not null default 0",
            "issued_at timestamptz not null default now()",
            "paid_at timestamptz null"
          ]
        },
        {
          "id": "billing.invoice_lines",
          "kind": "table",
          "details": [
            "columns: invoice_id uuid fk -> billing.invoices(id)",
            "line_no int not null",
            "description text not null",
            "amount_cents int not null",
            "primary key (invoice_id, line_no)"
          ]
        },
        {
          "id": "billing.metering_events",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid not null",
            "event_ts timestamptz not null default now()",
            "kind text not null  -- e.g. servers.running_minutes",
            "quantity numeric(18,4) not null",
            "dimensions jsonb not null default '{}'::jsonb",
            "indexes: (tenant_id, event_ts desc), gin(dimensions)"
          ]
        },
        {
          "id": "billing.v_current_entitlements",
          "kind": "view",
          "details": [
            "Purpose: derived current plan limits per tenant",
            "Definition: joins billing.subscriptions -> billing.plans where status in ('active','trialing')"
          ]
        },
        {
          "id": "billing.fn_apply_metering_event",
          "kind": "function",
          "details": [
            "signature: billing.fn_apply_metering_event(p_tenant uuid, p_kind text, p_qty numeric, p_dims jsonb) returns uuid",
            "notes: upserts aggregates; can be used by worker pipeline"
          ]
        },
        {
          "id": "billing.subscription_status",
          "kind": "enum",
          "details": [
            "values: trialing, active, past_due, cancelled, paused"
          ]
        },
        {
          "id": "billing.invoice_status",
          "kind": "enum",
          "details": [
            "values: open, paid, void"
          ]
        }
      ],
      "relationships": [
        {
          "from": "billing.subscriptions",
          "to": "billing.plans",
          "label": "subscriptions.plan_id -> plans.id"
        },
        {
          "from": "billing.invoice_lines",
          "to": "billing.invoices",
          "label": "invoice_lines.invoice_id -> invoices.id"
        }
      ]
    },
    {
      "key": "servers",
      "name": "Servers Service",
      "schema": "servers",
      "items": [
        {
          "id": "servers.server_templates",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid not null",
            "name text not null",
            "game_id text not null",
            "container_image text not null",
            "default_ports jsonb not null default '[]'::jsonb",
            "default_env jsonb not null default '{}'::jsonb",
            "created_at timestamptz not null default now()",
            "indexes: gin(default_ports), gin(default_env)"
          ]
        },
        {
          "id": "servers.game_servers",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid not null",
            "template_id uuid fk -> servers.server_templates(id)",
            "display_name text not null",
            "desired_state servers.server_state not null default 'stopped'",
            "current_state servers.server_state not null default 'stopped'",
            "node_id uuid not null  -- soft-ref to nodes service in SaaS",
            "user_db_target servers.user_db_target not null default 'managed'",
            "user_db_connection_id uuid null  -- soft-ref to files/secret store",
            "created_at timestamptz not null default now()",
            "updated_at timestamptz not null default now()",
            "indexes: (tenant_id, current_state), (node_id)"
          ]
        },
        {
          "id": "servers.server_allocations",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "server_id uuid fk -> servers.game_servers(id)",
            "protocol text not null  -- tcp/udp",
            "container_port int not null",
            "host_port int not null",
            "public bool not null default true",
            "unique (host_port, protocol)"
          ]
        },
        {
          "id": "servers.server_backups",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "server_id uuid fk -> servers.game_servers(id)",
            "kind servers.backup_kind not null default 'manual'",
            "status servers.backup_status not null default 'queued'",
            "object_key text null  -- points to object storage",
            "created_at timestamptz not null default now()",
            "completed_at timestamptz null"
          ]
        },
        {
          "id": "servers.v_servers_running",
          "kind": "view",
          "details": [
            "Purpose: quick list of running servers",
            "Definition: select * from servers.game_servers where current_state='running'"
          ]
        },
        {
          "id": "servers.fn_claim_backup_job",
          "kind": "function",
          "details": [
            "signature: servers.fn_claim_backup_job(p_worker text) returns uuid",
            "notes: uses FOR UPDATE SKIP LOCKED against servers.server_backups where status='queued'"
          ]
        },
        {
          "id": "servers.server_state",
          "kind": "enum",
          "details": [
            "values: stopped, starting, running, stopping, crashed, updating"
          ]
        },
        {
          "id": "servers.user_db_target",
          "kind": "enum",
          "details": [
            "values: managed, byo"
          ]
        },
        {
          "id": "servers.backup_kind",
          "kind": "enum",
          "details": [
            "values: manual, scheduled"
          ]
        },
        {
          "id": "servers.backup_status",
          "kind": "enum",
          "details": [
            "values: queued, running, succeeded, failed"
          ]
        }
      ],
      "relationships": [
        {
          "from": "servers.game_servers",
          "to": "servers.server_templates",
          "label": "game_servers.template_id -> server_templates.id"
        },
        {
          "from": "servers.server_allocations",
          "to": "servers.game_servers",
          "label": "allocations.server_id -> game_servers.id"
        },
        {
          "from": "servers.server_backups",
          "to": "servers.game_servers",
          "label": "backups.server_id -> game_servers.id"
        }
      ]
    },
    {
      "key": "nodes",
      "name": "Nodes Service",
      "schema": "nodes",
      "items": [
        {
          "id": "nodes.nodes",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "name text not null unique",
            "region text not null",
            "pool text not null",
            "status nodes.node_status not null default 'active'",
            "agent_id uuid null  -- soft-ref to agent service in SaaS",
            "tags jsonb not null default '[]'::jsonb",
            "capacity_cpu int not null, capacity_mem_mb int not null, capacity_disk_gb int not null",
            "created_at timestamptz not null default now()",
            "indexes: gin(tags), (region, pool, status)"
          ]
        },
        {
          "id": "nodes.node_heartbeats",
          "kind": "table",
          "details": [
            "columns: node_id uuid fk -> nodes.nodes(id)",
            "ts timestamptz not null default now()",
            "cpu_used_pct numeric(5,2) not null",
            "mem_used_pct numeric(5,2) not null",
            "disk_used_pct numeric(5,2) not null",
            "primary key (node_id, ts)",
            "indexes: (ts desc)"
          ]
        },
        {
          "id": "nodes.node_networks",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "node_id uuid fk -> nodes.nodes(id)",
            "public_ipv4 inet null",
            "public_ipv6 inet null",
            "private_cidr cidr null",
            "notes text null"
          ]
        },
        {
          "id": "nodes.v_node_health",
          "kind": "view",
          "details": [
            "Purpose: latest heartbeat per node",
            "Definition: distinct on(node_id) order by ts desc"
          ]
        },
        {
          "id": "nodes.fn_latest_heartbeat",
          "kind": "function",
          "details": [
            "signature: nodes.fn_latest_heartbeat(p_node uuid) returns timestamptz",
            "notes: used for UI health badges"
          ]
        },
        {
          "id": "nodes.node_status",
          "kind": "enum",
          "details": [
            "values: active, draining, disabled"
          ]
        }
      ],
      "relationships": [
        {
          "from": "nodes.node_heartbeats",
          "to": "nodes.nodes",
          "label": "heartbeats.node_id -> nodes.id"
        },
        {
          "from": "nodes.node_networks",
          "to": "nodes.nodes",
          "label": "networks.node_id -> nodes.id"
        }
      ]
    },
    {
      "key": "tasks",
      "name": "Tasks Service",
      "schema": "tasks",
      "items": [
        {
          "id": "tasks.jobs",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid null  -- null for platform-level jobs",
            "kind text not null  -- provision_server, backup, rotate_cert, ...",
            "status tasks.job_status not null default 'queued'",
            "payload jsonb not null default '{}'::jsonb",
            "attempt int not null default 0",
            "max_attempts int not null default 10",
            "run_after timestamptz not null default now()",
            "locked_by text null, locked_at timestamptz null",
            "created_at timestamptz not null default now()",
            "updated_at timestamptz not null default now()",
            "indexes: (status, run_after), gin(payload)"
          ]
        },
        {
          "id": "tasks.job_events",
          "kind": "table",
          "details": [
            "columns: id bigserial pk",
            "job_id uuid fk -> tasks.jobs(id)",
            "ts timestamptz not null default now()",
            "event text not null",
            "details jsonb not null default '{}'::jsonb"
          ]
        },
        {
          "id": "tasks.outbox",
          "kind": "table",
          "details": [
            "columns: id bigserial pk",
            "ts timestamptz not null default now()",
            "exchange text not null",
            "routing_key text not null",
            "payload jsonb not null",
            "published_at timestamptz null",
            "indexes: (published_at nulls first), (ts desc)"
          ]
        },
        {
          "id": "tasks.fn_dequeue_job",
          "kind": "function",
          "details": [
            "signature: tasks.fn_dequeue_job(p_worker text) returns uuid",
            "notes: FOR UPDATE SKIP LOCKED on tasks.jobs where status='queued' and run_after<=now()"
          ]
        },
        {
          "id": "tasks.job_status",
          "kind": "enum",
          "details": [
            "values: queued, running, succeeded, failed, cancelled"
          ]
        }
      ],
      "relationships": [
        {
          "from": "tasks.job_events",
          "to": "tasks.jobs",
          "label": "job_events.job_id -> jobs.id"
        }
      ]
    },
    {
      "key": "files",
      "name": "Files Service",
      "schema": "files",
      "items": [
        {
          "id": "files.artifacts",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid not null",
            "kind files.artifact_kind not null",
            "name text not null",
            "content_type text null",
            "size_bytes bigint not null default 0",
            "sha256 bytea null",
            "metadata jsonb not null default '{}'::jsonb",
            "created_at timestamptz not null default now()",
            "indexes: (tenant_id, kind), gin(metadata)"
          ]
        },
        {
          "id": "files.transfers",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "artifact_id uuid fk -> files.artifacts(id)",
            "direction files.transfer_direction not null",
            "status files.transfer_status not null default 'queued'",
            "signed_url text null",
            "expires_at timestamptz null",
            "created_at timestamptz not null default now()",
            "completed_at timestamptz null"
          ]
        },
        {
          "id": "files.v_ready_downloads",
          "kind": "view",
          "details": [
            "Purpose: active signed downloads",
            "Definition: select * from files.transfers where direction='download' and status='ready' and expires_at>now()"
          ]
        },
        {
          "id": "files.fn_mark_transfer_complete",
          "kind": "function",
          "details": [
            "signature: files.fn_mark_transfer_complete(p_transfer uuid) returns void",
            "notes: transitions status + timestamps (used by worker/webhook)"
          ]
        },
        {
          "id": "files.artifact_kind",
          "kind": "enum",
          "details": [
            "values: backup, world, config, log_bundle, image"
          ]
        },
        {
          "id": "files.transfer_direction",
          "kind": "enum",
          "details": [
            "values: upload, download"
          ]
        },
        {
          "id": "files.transfer_status",
          "kind": "enum",
          "details": [
            "values: queued, ready, running, succeeded, failed, expired"
          ]
        }
      ],
      "relationships": [
        {
          "from": "files.transfers",
          "to": "files.artifacts",
          "label": "transfers.artifact_id -> artifacts.id"
        }
      ]
    },
    {
      "key": "notifications",
      "name": "Notifications Service",
      "schema": "notifications",
      "items": [
        {
          "id": "notifications.templates",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid null",
            "channel notifications.channel not null",
            "code text not null",
            "subject text null",
            "body text not null",
            "active bool not null default true",
            "unique (tenant_id, channel, code)"
          ]
        },
        {
          "id": "notifications.events",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid null",
            "event_ts timestamptz not null default now()",
            "kind text not null",
            "payload jsonb not null default '{}'::jsonb",
            "indexes: (event_ts desc), gin(payload)"
          ]
        },
        {
          "id": "notifications.deliveries",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "event_id uuid fk -> notifications.events(id)",
            "channel notifications.channel not null",
            "status notifications.delivery_status not null default 'queued'",
            "destination text not null",
            "attempt int not null default 0",
            "last_error text null",
            "created_at timestamptz not null default now()",
            "sent_at timestamptz null"
          ]
        },
        {
          "id": "notifications.webhooks",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid not null",
            "url text not null",
            "secret_hash text null",
            "active bool not null default true",
            "created_at timestamptz not null default now()"
          ]
        },
        {
          "id": "notifications.fn_enqueue_delivery",
          "kind": "function",
          "details": [
            "signature: notifications.fn_enqueue_delivery(p_event uuid, p_channel notifications.channel, p_dest text) returns uuid",
            "notes: creates delivery row + publishes to bus"
          ]
        },
        {
          "id": "notifications.channel",
          "kind": "enum",
          "details": [
            "values: email, webhook, discord, inapp"
          ]
        },
        {
          "id": "notifications.delivery_status",
          "kind": "enum",
          "details": [
            "values: queued, running, sent, failed"
          ]
        }
      ],
      "relationships": [
        {
          "from": "notifications.deliveries",
          "to": "notifications.events",
          "label": "deliveries.event_id -> events.id"
        }
      ]
    },
    {
      "key": "firewall",
      "name": "Firewall Service",
      "schema": "firewall",
      "items": [
        {
          "id": "firewall.policies",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "tenant_id uuid not null",
            "name text not null",
            "mode firewall.policy_mode not null default 'allowlist'",
            "created_at timestamptz not null default now()",
            "unique (tenant_id, name)"
          ]
        },
        {
          "id": "firewall.rules",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "policy_id uuid fk -> firewall.policies(id)",
            "direction firewall.direction not null",
            "protocol text not null  -- tcp/udp",
            "port_range int4range not null",
            "source_cidr cidr null",
            "enabled bool not null default true",
            "notes text null",
            "indexes: gist(port_range)"
          ]
        },
        {
          "id": "firewall.v_effective_rules",
          "kind": "view",
          "details": [
            "Purpose: enabled rules only",
            "Definition: select * from firewall.rules where enabled=true"
          ]
        },
        {
          "id": "firewall.fn_rules_for_node",
          "kind": "function",
          "details": [
            "signature: firewall.fn_rules_for_node(p_tenant uuid) returns setof firewall.rules",
            "notes: used by agent to fetch current policy"
          ]
        },
        {
          "id": "firewall.policy_mode",
          "kind": "enum",
          "details": [
            "values: allowlist, blocklist"
          ]
        },
        {
          "id": "firewall.direction",
          "kind": "enum",
          "details": [
            "values: inbound, outbound"
          ]
        }
      ],
      "relationships": [
        {
          "from": "firewall.rules",
          "to": "firewall.policies",
          "label": "rules.policy_id -> policies.id"
        }
      ]
    },
    {
      "key": "agent",
      "name": "Agent Coordinator",
      "schema": "agent",
      "items": [
        {
          "id": "agent.agents",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "node_id uuid not null  -- soft-ref to nodes in SaaS",
            "machine_fingerprint text not null",
            "status agent.agent_status not null default 'pending'",
            "last_seen_at timestamptz null",
            "registered_at timestamptz not null default now()",
            "unique (machine_fingerprint)"
          ]
        },
        {
          "id": "agent.agent_certificates",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "agent_id uuid fk -> agent.agents(id)",
            "thumbprint text not null",
            "not_before timestamptz not null",
            "not_after timestamptz not null",
            "revoked_at timestamptz null",
            "unique (agent_id, thumbprint)"
          ]
        },
        {
          "id": "agent.commands",
          "kind": "table",
          "details": [
            "columns: id uuid pk default gen_random_uuid()",
            "agent_id uuid fk -> agent.agents(id)",
            "kind text not null",
            "payload jsonb not null default '{}'::jsonb",
            "status agent.command_status not null default 'queued'",
            "created_at timestamptz not null default now()",
            "claimed_at timestamptz null",
            "completed_at timestamptz null",
            "indexes: (agent_id, status), gin(payload)"
          ]
        },
        {
          "id": "agent.command_results",
          "kind": "table",
          "details": [
            "columns: command_id uuid pk fk -> agent.commands(id)",
            "success bool not null",
            "output text null",
            "metrics jsonb not null default '{}'::jsonb"
          ]
        },
        {
          "id": "agent.fn_claim_command",
          "kind": "function",
          "details": [
            "signature: agent.fn_claim_command(p_agent uuid) returns uuid",
            "notes: SKIP LOCKED claim pattern by agent"
          ]
        },
        {
          "id": "agent.agent_status",
          "kind": "enum",
          "details": [
            "values: pending, active, disabled"
          ]
        },
        {
          "id": "agent.command_status",
          "kind": "enum",
          "details": [
            "values: queued, running, succeeded, failed"
          ]
        }
      ],
      "relationships": [
        {
          "from": "agent.agent_certificates",
          "to": "agent.agents",
          "label": "agent_certificates.agent_id -> agents.id"
        },
        {
          "from": "agent.commands",
          "to": "agent.agents",
          "label": "commands.agent_id -> agents.id"
        },
        {
          "from": "agent.command_results",
          "to": "agent.commands",
          "label": "command_results.command_id -> commands.id"
        }
      ]
    }
  ]
}